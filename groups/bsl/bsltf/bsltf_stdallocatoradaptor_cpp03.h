// bsltf_stdallocatoradaptor_cpp03.h                                  -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLTF_STDALLOCATORADAPTOR_CPP03
#define INCLUDED_BSLTF_STDALLOCATORADAPTOR_CPP03

//@PURPOSE: Provide C++03 implementation for bsltf_stdallocatoradaptor.h
//
//@CLASSES: See bsltf_stdallocatoradaptor.h for list of classes
//
//@SEE_ALSO: bsltf_stdallocatoradaptor
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Mon Feb 28 19:11:05 2022
// Command line: sim_cpp11_features.pl bsltf_stdallocatoradaptor.h

#ifdef COMPILING_BSLTF_STDALLOCATORADAPTOR_H

namespace BloombergLP {
namespace bsltf {

                        // =========================
                        // class StdAllocatorAdaptor
                        // =========================

template <class ALLOCATOR>
class StdAllocatorAdaptor : public ALLOCATOR {
    // This class template provides the facade of an allocator but mostly
    // delegates operations to the allocator object (of template parameter
    // type) it adapts, except that it enables the propagation of the
    // (stateful) allocator object to constructed elements, if appropriate.

    // PRIVATE TYPES
    typedef bsl::allocator_traits<ALLOCATOR> AllocatorTraits;

    // PRIVATE MANIPULATORS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bsltf_stdallocatoradaptor.h
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#endif
#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class Args_01>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 14


#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class Args_01>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_A >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class ELEMENT_TYPE, class... Args>
    void privateConstruct(bsl::true_type,
                          ELEMENT_TYPE *elemAddr,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments);

    template <class ELEMENT_TYPE, class... Args>
    void privateConstruct(bsl::false_type,
                          ELEMENT_TYPE *elemAddr,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments);

// }}} END GENERATED CODE
#endif

  public:
    // PUBLIC TYPES
    typedef typename ALLOCATOR::size_type       size_type;
    typedef typename ALLOCATOR::difference_type difference_type;
    typedef typename ALLOCATOR::pointer         pointer;
    typedef typename ALLOCATOR::const_pointer   const_pointer;
    typedef typename ALLOCATOR::reference       reference;
    typedef typename ALLOCATOR::const_reference const_reference;
    typedef typename ALLOCATOR::value_type      value_type;

    template <class BDE_OTHER_TYPE>
    struct rebind
    {
        // This nested 'struct' template, parameterized by some
        // 'BDE_OTHER_TYPE', provides a namespace for an 'other' type alias,
        // which is an allocator type following the same template as this one
        // but that allocates elements of 'BDE_OTHER_TYPE'.  Note that this
        // allocator type is convertible to and from 'other' for any
        // 'BDE_OTHER_TYPE' including 'void'.

        typedef StdAllocatorAdaptor<
             typename ALLOCATOR::template rebind<BDE_OTHER_TYPE>::other> other;
    };

    // CREATORS
    StdAllocatorAdaptor();
        // Create a standard allocator adaptor object for a default-constructed
        // allocator object of the (template parameter) type 'ALLOCATOR'.

    explicit StdAllocatorAdaptor(const ALLOCATOR& allocator);
        // Create a standard allocator adaptor object for the specified
        // 'allocator' of the (template parameter) type 'ALLOCATOR'.

    explicit StdAllocatorAdaptor(bsl::nullptr_t);
        // Create a standard allocator adaptor object from the null pointer
        // constant.

    template <class ANY_TYPE>
    StdAllocatorAdaptor(const StdAllocatorAdaptor<ANY_TYPE>& other);
        // Create a copy of the specified 'other' allocator adaptor.

#ifdef BSLS_COMPILERFEATURES_SUPPORT_DEFAULTED_FUNCTIONS
    StdAllocatorAdaptor(const StdAllocatorAdaptor& original) = default;
        // Create a copy of the specified 'original' allocator adaptor.
#else
    //! StdAllocatorAdaptor(const StdAllocatorAdaptor& original) = default;
#endif

    //! ~StdAllocatorAdaptor() = default;
        // Destroy this object.

    // MANIPULATORS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_DEFAULTED_FUNCTIONS
    StdAllocatorAdaptor& operator=(const StdAllocatorAdaptor& original) =
                                                                       default;
        // Assign to this object the value of the specified 'rhs' object, and
        // return a reference providing modifiable access to this object.
#else
    //! StdAllocatorAdaptor& operator=(const StdAllocatorAdaptor& rhs) =
    //!                                                                default;
#endif

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bsltf_stdallocatoradaptor.h
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#endif
#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 0
    template <class ELEMENT_TYPE>
    void construct(ELEMENT_TYPE *address);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 1
    template <class ELEMENT_TYPE, class Args_01>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14);
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_B >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class ELEMENT_TYPE, class... Args>
    void construct(ELEMENT_TYPE *address,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments);
// }}} END GENERATED CODE
#endif

    // ACCESSORS
    const ALLOCATOR& allocator() const;
        // Return a reference to the non-modifiable allocator instance
        // associated with this standard allocator adaptor.

    StdAllocatorAdaptor<ALLOCATOR>
                                 select_on_container_copy_construction() const;
        // Return an allocator adaptor for the allocator object returned by the
        // 'select_on_container_copy_construction' class method in the
        // 'allocator_traits' class template for the allocator object, of the
        // (template parameter) type 'ALLOCATOR', associated with this adaptor.
        // The 'allocator_traits' class template presumably delegates this call
        // to the allocator object if such an operation is supported by the
        // 'ALLOCATOR' type, or provides a suitable default behavior if such an
        // operation is not supported.
};

// FREE OPERATORS
template <class TYPE1, class TYPE2>
bool operator==(const StdAllocatorAdaptor<TYPE1>& lhs,
                const StdAllocatorAdaptor<TYPE2>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' adaptors are equal and
    // 'false' otherwise.  Two allocator adaptor instances are equal if their
    // associated allocator instances are equal.

template <class TYPE1, class TYPE2>
bool operator!=(const StdAllocatorAdaptor<TYPE1>& lhs,
                const StdAllocatorAdaptor<TYPE2>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' adaptors are not equal
    // and 'false' otherwise.  Two allocator adaptor instances are not equal if
    // their associated allocator instances are not equal.

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                        // -------------------------
                        // class StdAllocatorAdaptor
                        // -------------------------

// PRIVATE MANIPULATORS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bsltf_stdallocatoradaptor.h
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#endif
#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 0
template <class ALLOCATOR>
template <class ELEMENT_TYPE>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address)
{
    AllocatorTraits::construct(
        *this,
        address,
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 1
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 2
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 3
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 4
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 5
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 6
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 7
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 8
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 9
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 10
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 11
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 12
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 13
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 14
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13,
                              class Args_14>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
        BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14),
        *this);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 14


#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 0
template <class ALLOCATOR>
template <class ELEMENT_TYPE>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address)
{
    AllocatorTraits::construct(
        *this, address);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 1
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 2
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 3
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 4
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 5
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 6
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 7
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 8
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 9
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 10
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 11
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 12
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 13
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 14
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13,
                              class Args_14>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
                        BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_C >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class... Args>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                     bsl::true_type,
                                                     ELEMENT_TYPE   *address,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
{
    AllocatorTraits::construct(
        *this,
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...,
        *this);
}

template <class ALLOCATOR>
template <class ELEMENT_TYPE, class... Args>
inline
void StdAllocatorAdaptor<ALLOCATOR>::privateConstruct(
                                                    bsl::false_type,
                                                    ELEMENT_TYPE    *address,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
{
    AllocatorTraits::construct(
        *this, address, BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
}

// }}} END GENERATED CODE
#endif

// CREATORS
template <class ALLOCATOR>
inline
StdAllocatorAdaptor<ALLOCATOR>::StdAllocatorAdaptor()
: ALLOCATOR()
{
}

template <class ALLOCATOR>
inline
StdAllocatorAdaptor<ALLOCATOR>::StdAllocatorAdaptor(const ALLOCATOR& allocator)
: ALLOCATOR(allocator)
{
}

template <class ALLOCATOR>
inline
StdAllocatorAdaptor<ALLOCATOR>::StdAllocatorAdaptor(bsl::nullptr_t)
: ALLOCATOR(0)
{
}

template <class ALLOCATOR>
template <class ANY_TYPE>
inline
StdAllocatorAdaptor<ALLOCATOR>::StdAllocatorAdaptor(
                                    const StdAllocatorAdaptor<ANY_TYPE>& other)
: ALLOCATOR(other)
{
}

// MANIPULATORS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bsltf_stdallocatoradaptor.h
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D
#define BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT
#endif
#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 0
template <class ALLOCATOR>
template <class ELEMENT_TYPE>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address);
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 0

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 1
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 1

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 2
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 2

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 3
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 3

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 4
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 4

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 5
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 5

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 6
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 6

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 7
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 7

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 8
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 8

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 9
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 9

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 10
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 10

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 11
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 11

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 12
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 12

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 13
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 13

#if BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 14
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13,
                              class Args_14>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
        BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
}
#endif  // BSLTF_STDALLOCATORADAPTOR_VARIADIC_LIMIT_D >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class ALLOCATOR>
template <class ELEMENT_TYPE, class... Args>
inline void
StdAllocatorAdaptor<ALLOCATOR>::construct(ELEMENT_TYPE *address,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
{
    enum { k_PassSelfAtEnd =
        bsl::uses_allocator<ELEMENT_TYPE, StdAllocatorAdaptor>::value &&
        ! bsl::is_convertible<StdAllocatorAdaptor *,
                              bsl::allocator<value_type> *>::value
    };

    privateConstruct(
        bsl::integral_constant<bool, (bool) k_PassSelfAtEnd>(),
        address,
        BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
}
// }}} END GENERATED CODE
#endif

// ACCESSORS
template <class ALLOCATOR>
inline
const ALLOCATOR& StdAllocatorAdaptor<ALLOCATOR>::allocator() const
{
    return *this;
}

template <class ALLOCATOR>
inline
StdAllocatorAdaptor<ALLOCATOR>
StdAllocatorAdaptor<ALLOCATOR>::select_on_container_copy_construction() const
{
    return StdAllocatorAdaptor<ALLOCATOR>(
        AllocatorTraits::select_on_container_copy_construction(
            *reinterpret_cast<const ALLOCATOR *>(this)));
}

// FREE OPERATORS
template <class TYPE1, class TYPE2>
inline
bool operator==(const bsltf::StdAllocatorAdaptor<TYPE1>& lhs,
                const bsltf::StdAllocatorAdaptor<TYPE2>& rhs)
{
    return lhs.allocator() == rhs.allocator();
}

template <class TYPE1, class TYPE2>
inline
bool operator!=(const bsltf::StdAllocatorAdaptor<TYPE1>& lhs,
                const bsltf::StdAllocatorAdaptor<TYPE2>& rhs)
{
    return lhs.allocator() != rhs.allocator();
}

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLTF_STDALLOCATORADAPTOR_H)
# error Not valid except when included from bsltf_stdallocatoradaptor.h
#endif // ! defined(COMPILING_BSLTF_STDALLOCATORADAPTOR_H)

#endif // ! defined(INCLUDED_BSLTF_STDALLOCATORADAPTOR_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
