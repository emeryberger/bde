// bslstl_queue_cpp03.h                                               -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_QUEUE_CPP03
#define INCLUDED_BSLSTL_QUEUE_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_queue.h
//
//@CLASSES: See bslstl_queue.h for list of classes
//
//@SEE_ALSO: bslstl_queue
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Mon Apr 10 03:24:44 2023
// Command line: sim_cpp11_features.pl bslstl_queue.h

#ifdef COMPILING_BSLSTL_QUEUE_H

namespace bsl {

                             // ===========
                             // class queue
                             // ===========

template <class VALUE, class CONTAINER = deque<VALUE> >
class queue {
    // This class is a value-semantic class template, having a container of the
    // parameterized 'CONTAINER' type that holds elements of the parameterized
    // 'VALUE' type, to provide a first-in-first-out queue data structure.  The
    // container object held by a 'queue' class object is referenced as 'c' in
    // the following function-level documentation.

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
    // STATIC CHECK: Type mismatch is UB per C++17
    BSLMF_ASSERT((is_same<VALUE, typename CONTAINER::value_type>::value));
#endif

    // FRIENDS
    template <class VALUE2, class CONTAINER2>
    friend bool operator==(const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

    template <class VALUE2, class CONTAINER2>
    friend bool operator!=(const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

    template <class VALUE2, class CONTAINER2>
    friend bool operator< (const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

    template <class VALUE2, class CONTAINER2>
    friend bool operator> (const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

    template <class VALUE2, class CONTAINER2>
    friend bool operator<=(const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

    template <class VALUE2, class CONTAINER2>
    friend bool operator>=(const queue<VALUE2, CONTAINER2>&,
                           const queue<VALUE2, CONTAINER2>&);

#if defined BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON \
 && defined BSLS_LIBRARYFEATURES_HAS_CPP20_CONCEPTS
    template <class VALUE2, three_way_comparable CONTAINER2>
    friend compare_three_way_result_t<CONTAINER2>
    operator<=>(const queue<VALUE2, CONTAINER2>&,
                const queue<VALUE2, CONTAINER2>&);
#endif

    // PRIVATE TYPES
    typedef BloombergLP::bslmf::MovableRefUtil  MoveUtil;
        // This 'typedef' is a convenient alias for the utility associated with
        // movable references.

  public:
    // PUBLIC TYPES
    typedef typename CONTAINER::value_type      value_type;
    typedef typename CONTAINER::reference       reference;
    typedef typename CONTAINER::const_reference const_reference;
    typedef typename CONTAINER::size_type       size_type;
    typedef          CONTAINER                  container_type;

  protected:
    // PROTECTED DATA
    CONTAINER c;  // Contains the elements of this queue.
                  // 'protected' and named ('c') per the C++11 standard.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        queue,
        BloombergLP::bslma::UsesBslmaAllocator,
        BloombergLP::bslma::UsesBslmaAllocator<container_type>::value);

    // CREATORS
    explicit queue();
        // Create an empty queue having a container of the parameterized
        // 'CONTAINER' type.

    queue(const queue& original);
        // Create a queue having the value of the specified 'original'.

    queue(BloombergLP::bslmf::MovableRef<queue> container);
        // Create a queue having the value of the specified 'original'.  The
        // allocator associated with 'original' (if any) is propagated for use
        // in the new queue.  'original' is left in valid but unspecified
        // state.

    explicit queue(const CONTAINER& container);
        // Create a queue having the specified 'container' that holds elements
        // of the parameterized 'VALUE' type.

    explicit queue(BloombergLP::bslmf::MovableRef<CONTAINER> container);
        // Create a queue having the same sequence of values as the specified
        // 'container'.  The allocator associated with 'container' (if any) is
        // propagated for use in the new queue.  'container' is left in valid
        // but unspecified state.

    template <class ALLOCATOR>
    explicit
    queue(const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create an empty queue.  This queue object uses the specified
        // 'basicAllocator' to supply memory.  Note that the 'ALLOCATOR'
        // parameter type has to be convertible to the allocator of the
        // 'CONTAINER' parameter type, 'CONTAINER::allocator_type'; otherwise,
        // this constructor is disabled.

    template <class ALLOCATOR>
    queue(const CONTAINER& container,
          const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a queue having the same sequence of values as the specified
        // 'container'.  The queue object uses the specified 'basicAllocator'
        // to obtain memory.  Note that the 'ALLOCATOR' parameter type has to
        // be convertible to the allocator of the 'CONTAINER' parameter type,
        // 'CONTAINER::allocator_type'; otherwise, this constructor is
        // disabled.

    template <class ALLOCATOR>
    queue(const queue&     original,
          const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a queue having the value of the specified 'original' that
        // will use the specified 'basicAllocator' to supply memory.  Note that
        // the 'ALLOCATOR' parameter type has to be convertible to the
        // allocator of the 'CONTAINER' parameter type,
        // 'CONTAINER::allocator_type'.  Otherwise this constructor is
        // disabled.

    template <class ALLOCATOR>
    queue(BloombergLP::bslmf::MovableRef<CONTAINER> container,
          const ALLOCATOR&                          basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a queue whose underlying container has the value of the
        // specified 'container' (on entry) and uses 'basicAllocator' to supply
        // memory.  The allocated-extended move constructor of 'CONTAINER' is
        // used to create the new queue.  'container' is left in a valid but
        // unspecified state.  Note that a 'bslma::Allocator *' can be supplied
        // for 'basicAllocator' if the (template parameter) 'ALLOCATOR' is
        // 'bsl::allocator' (the default).  Also note that this method assumes
        // that 'CONTAINER' has a move constructor.  Also note that if
        // 'CONTAINER::allocator_type' does not exist, this constructor is
        // disabled.

    template <class ALLOCATOR>
    queue(BloombergLP::bslmf::MovableRef<queue> original,
          const ALLOCATOR&                      basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a queue having the value of the specified 'original' (on
        // entry), that uses 'basicAllocator' to supply memory.  The
        // allocator-extended move constructor of 'CONTAINER' is used to create
        // the new queue.  'original' is left in a valid but unspecified state.
        // Note that a 'bslma::Allocator *' can be supplied for
        // 'basicAllocator' if the (template parameter) 'ALLOCATOR' is
        // 'bsl::allocator' (the default).  Also note that this method assumes
        // that 'CONTAINER' has a move constructor.  Also note that if
        // 'CONTAINER::allocator_type' does not exist, this constructor is
        // disabled.

    // MANIPULATORS
    queue& operator=(const queue& rhs);
        // Assign to this queue the value of the specified 'rhs', and return a
        // reference providing modifiable access to this queue.

    queue& operator=(BloombergLP::bslmf::MovableRef<queue> rhs);
        // Assign to this queue the value as the specified 'rhs' and return a
        // reference providing modifiable access to this queue.  The
        // move-assignment operator of 'CONTAINER' is used to set the value of
        // this queue.  'rhs' is left in a valid but unspecified state, and if
        // an exception is thrown, '*this' is left in a valid but unspecified
        // state.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_queue.h
#ifndef BSLSTL_QUEUE_VARIADIC_LIMIT
#define BSLSTL_QUEUE_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_QUEUE_VARIADIC_LIMIT_A
#define BSLSTL_QUEUE_VARIADIC_LIMIT_A BSLSTL_QUEUE_VARIADIC_LIMIT
#endif
#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 0
    reference emplace();
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 0

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 1
    template <class Args_01>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 1

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 2
    template <class Args_01,
              class Args_02>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 2

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 3

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 4

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 5

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 6

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 7

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 8

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 9

#if BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_A >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... Args>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

// }}} END GENERATED CODE
#endif

    void push(const value_type& value);
        // Push onto the back of this queue a 'value_type' object having the
        // specified 'value'.

    void push(BloombergLP::bslmf::MovableRef<value_type> value);
        // Push onto the back of this queue a 'value_type' object having the
        // value of the specified 'value' (on entry) by moving the
        // contents of 'value' to the new object on this queue.  'value' is
        // left in a valid but unspecified state.

    void pop();
        // Remove the front (the earliest pushed) element from this 'queue'
        // object.

    void swap(queue& other) BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                  bsl::is_nothrow_swappable<CONTAINER>::value);
        // Efficiently exchange the value of this object with the value of the
        // specified 'other' object.  In effect, performs
        // 'using bsl::swap; swap(c, other.c);'.

    reference front();
        // Return a reference providing modifiable access to the front (the
        // earliest pushed) element from this 'queue' object.

    reference back();
        // Return a reference providing modifiable access to the back (the
        // latest pushed) element of this 'queue' object.

    // ACCESSORS
    bool empty() const;
        // Return 'true' if this 'queue' object contains no elements, and
        // 'false' otherwise.  In effect, performs 'return c.empty();'.

    size_type size() const;
        // Return the number of elements in this queue.  In effect, performs
        // 'return c.size();'.

    const_reference front() const;
        // Return the immutable front (the earliest pushed) element from this
        // 'queue' object.  In effect, performs 'c.front()'.

    const_reference back() const;
        // Return the immutable back (the latest pushed) element from this
        // 'queue' object.  In effect, performs 'c.back()'.
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
// CLASS TEMPLATE DEDUCTION GUIDES

template<class CONTAINER,
         class = bsl::enable_if_t<!bsl::IsStdAllocator_v<CONTAINER>>
        >
queue(CONTAINER) -> queue<typename CONTAINER::value_type, CONTAINER>;
    // Deduce the template parameters 'VALUE' and 'CONTAINER' from the
    // parameters supplied to the constructor of 'queue'.  This deduction guide
    // does not participate if the parameter meets the requirements for a
    // standard allocator.

template<
    class CONTAINER,
    class ALLOCATOR,
    class = bsl::enable_if_t<bsl::uses_allocator_v<CONTAINER, ALLOCATOR>>
    >
queue(CONTAINER, ALLOCATOR) -> queue<typename CONTAINER::value_type, CONTAINER>;
    // Deduce the template parameters 'VALUE' and 'CONTAINER' from the
    // parameters supplied to the constructor of 'queue'.  This deduction
    // guide does not participate unless the supplied allocator is convertible
    // to the underlying container's 'allocator_type'.
#endif

// FREE OPERATORS
template <class VALUE, class CONTAINER>
bool operator==(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'queue' objects 'lhs' and 'rhs' have
    // the same value if they have the same number of elements, and each
    // element in the ordered sequence of elements of 'lhs' has the same value
    // as the corresponding element in the ordered sequence of elements of
    // 'rhs'.  This method requires that the (template parameter) type 'VALUE'
    // be 'equality-comparable' (see {Requirements on 'VALUE'}).

template <class VALUE, class CONTAINER>
bool operator!=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'queue' objects 'lhs' and 'rhs'
    // do not have the same value if they do not have the same number of
    // elements, or some element in the ordered sequence of elements of 'lhs'
    // does not have the same value as the corresponding element in the ordered
    // sequence of elements of 'rhs'.  This method requires that the (template
    // parameter) type 'VALUE' be 'equality-comparable' (see {Requirements on
    // 'VALUE'}).

template <class VALUE, class CONTAINER>
bool operator< (const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' queue is
    // lexicographically less than that of the specified 'rhs' queue, and
    // 'false' otherwise.  Given iterators 'i' and 'j' over the respective
    // sequences '[lhs.begin() .. lhs.end())' and '[rhs.begin() .. rhs.end())',
    // the value of queue 'lhs' is lexicographically less than that of queue
    // 'rhs' if 'true == *i < *j' for the first pair of corresponding iterator
    // positions where '*i < *j' and '*j < *i' are not both 'false'.  If no
    // such corresponding iterator position exists, the value of 'lhs' is
    // lexicographically less than that of 'rhs' if 'lhs.size() < rhs.size()'.
    // This method requires that 'operator<', inducing a total order, be
    // defined for 'value_type'.

template <class VALUE, class CONTAINER>
bool operator> (const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' queue is
    // lexicographically greater than that of the specified 'rhs' queue, and
    // 'false' otherwise.  The value of queue 'lhs' is lexicographically
    // greater than that of queue 'rhs' if 'rhs' is lexicographically less than
    // 'lhs' (see 'operator<').  This method requires that 'operator<',
    // inducing a total order, be defined for 'value_type'.  Note that this
    // operator returns 'rhs < lhs'.

template <class VALUE, class CONTAINER>
bool operator<=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' queue is
    // lexicographically less than or equal to that of the specified 'rhs'
    // queue, and 'false' otherwise.  The value of queue 'lhs' is
    // lexicographically less than or equal to that of queue 'rhs' if 'rhs' is
    // not lexicographically less than 'lhs' (see 'operator<').  This method
    // requires that 'operator<', inducing a total order, be defined for
    // 'value_type'.  Note that this operator returns '!(rhs < lhs)'.

template <class VALUE, class CONTAINER>
bool operator>=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' queue is
    // lexicographically greater than or equal to that of the specified 'rhs'
    // queue, and 'false' otherwise.  The value of queue 'lhs' is
    // lexicographically greater than or equal to that of queue 'rhs' if 'lhs'
    // is not lexicographically less than 'rhs' (see 'operator<').  This method
    // requires that 'operator<', inducing a total order, be defined for
    // 'value_type'.  Note that this operator returns '!(lhs < rhs)'.

// FREE FUNCTIONS
template <class VALUE, class CONTAINER>
void swap(queue<VALUE, CONTAINER>& lhs,
          queue<VALUE, CONTAINER>& rhs)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);
    // Swap the value of the specified 'lhs' queue with the value of the
    // specified 'rhs' queue.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                              // -----------
                              // class queue
                              // -----------

// CREATORS
template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>::queue()
{
}

template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>::queue(const queue& original)
: c(original.c)
{
}

template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>::queue(BloombergLP::bslmf::MovableRef<queue> original)
: c(MoveUtil::move(MoveUtil::access(original).c))
{
}

template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>::queue(const CONTAINER& container)
: c(container)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
queue<VALUE, CONTAINER>::queue(
           const ALLOCATOR& basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(basicAllocator)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
queue<VALUE, CONTAINER>::queue(
           const CONTAINER& container,
           const ALLOCATOR& basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(container, basicAllocator)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
queue<VALUE, CONTAINER>::queue(
           const queue&     queue,
           const ALLOCATOR& basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(queue.c, basicAllocator)
{
}

template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>::queue(BloombergLP::bslmf::MovableRef<CONTAINER>
                                                                     container)
: c(MoveUtil::move(container))
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
queue<VALUE, CONTAINER>::queue(
           BloombergLP::bslmf::MovableRef<CONTAINER> container,
           const ALLOCATOR&                          basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(MoveUtil::move(container), basicAllocator)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
queue<VALUE, CONTAINER>::queue(
           BloombergLP::bslmf::MovableRef<queue> original,
           const ALLOCATOR&                      basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(MoveUtil::move(MoveUtil::access(original).c), basicAllocator)
{
}

// MANIPULATORS
template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>& queue<VALUE, CONTAINER>::operator=(const queue& rhs)
{
    c = rhs.c;
    return *this;
}

template <class VALUE, class CONTAINER>
inline
queue<VALUE, CONTAINER>& queue<VALUE, CONTAINER>::operator=(
                                     BloombergLP::bslmf::MovableRef<queue> rhs)
{
    c = MoveUtil::move(MoveUtil::access(rhs).c);
    return *this;
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_queue.h
#ifndef BSLSTL_QUEUE_VARIADIC_LIMIT
#define BSLSTL_QUEUE_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_QUEUE_VARIADIC_LIMIT_B
#define BSLSTL_QUEUE_VARIADIC_LIMIT_B BSLSTL_QUEUE_VARIADIC_LIMIT
#endif
#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 0
template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                               )
{
    c.emplace_back();
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 0

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 1
template <class VALUE, class CONTAINER>
template <class Args_01>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 1

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 2
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 2

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 3
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 3

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 4
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 4

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 5
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 5

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 6
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 6

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 7
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 7

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 8
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 8

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 9
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 9

#if BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 10
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09),
                   BSLS_COMPILERFEATURES_FORWARD(Args_10,args_10));
    return back();
}
#endif  // BSLSTL_QUEUE_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class VALUE, class CONTAINER>
template <class... Args>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
    return back();
}
// }}} END GENERATED CODE
#endif

template <class VALUE, class CONTAINER>
inline
void queue<VALUE, CONTAINER>::push(const value_type& value)
{
    c.push_back(value);
}

template <class VALUE, class CONTAINER>
inline
void queue<VALUE, CONTAINER>::push(BloombergLP::bslmf::MovableRef<value_type>
                                                                         value)
{
    c.push_back(MoveUtil::move(value));
}

template <class VALUE, class CONTAINER>
inline
void queue<VALUE, CONTAINER>::pop()
{
    c.pop_front();
}

template <class VALUE, class CONTAINER>
inline
void queue<VALUE, CONTAINER>::swap(queue& other)
    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                   bsl::is_nothrow_swappable<CONTAINER>::value)
{
    BloombergLP::bslalg::SwapUtil::swap(&c, &other.c);
}

// ACCESSORS
template <class VALUE, class CONTAINER>
inline
bool queue<VALUE, CONTAINER>::empty() const
{
    return c.empty();
}

template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::size_type
queue<VALUE, CONTAINER>::size() const
{
    return c.size();
}

template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::front()
{
    return c.front();
}

template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::const_reference
queue<VALUE, CONTAINER>::front() const
{
    return c.front();
}

template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::reference
queue<VALUE, CONTAINER>::back()
{
    return c.back();
}

template <class VALUE, class CONTAINER>
inline
typename queue<VALUE, CONTAINER>::const_reference
queue<VALUE, CONTAINER>::back() const
{
    return c.back();
}

// FREE OPERATORS
template <class VALUE, class CONTAINER>
inline
bool operator==(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c == rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator!=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c != rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator< (const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c < rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator> (const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c > rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator<=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c <= rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator>=(const queue<VALUE, CONTAINER>& lhs,
                const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c >= rhs.c;
}

#if defined BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON \
 && defined BSLS_LIBRARYFEATURES_HAS_CPP20_CONCEPTS
template <class VALUE, three_way_comparable CONTAINER>
inline compare_three_way_result_t<CONTAINER>
operator<=>(const queue<VALUE, CONTAINER>& lhs,
            const queue<VALUE, CONTAINER>& rhs)
{
    return lhs.c <=> rhs.c;
}
#endif

// FREE FUNCTIONS
template <class VALUE, class CONTAINER>
inline
void swap(queue<VALUE, CONTAINER>& lhs,
          queue<VALUE, CONTAINER>& rhs)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    lhs.swap(rhs);
}

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLSTL_QUEUE_H)
# error Not valid except when included from bslstl_queue.h
#endif // ! defined(COMPILING_BSLSTL_QUEUE_H)

#endif // ! defined(INCLUDED_BSLSTL_QUEUE_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
