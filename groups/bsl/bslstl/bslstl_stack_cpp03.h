// bslstl_stack_cpp03.h                                               -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_STACK_CPP03
#define INCLUDED_BSLSTL_STACK_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_stack.h
//
//@CLASSES: See bslstl_stack.h for list of classes
//
//@SEE_ALSO: bslstl_stack
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Mon Apr 10 03:06:52 2023
// Command line: sim_cpp11_features.pl bslstl_stack.h

#ifdef COMPILING_BSLSTL_STACK_H

namespace bsl {

                             // ===========
                             // class stack
                             // ===========

template <class VALUE, class CONTAINER = deque<VALUE> >
class stack {
    // This 'class' defines a container adapter which supports access primarily
    // via 'push', 'pop', and 'top'.  This type can be based on a variety of
    // other container types, including 'deque', 'vector', and 'list'.  This
    // type is value-semantic if the supporting 'CONTAINER' and 'VALUE' are
    // value-semantic.
    //
    // Note that we never use 'VALUE' in the implementation except in the
    // default argument of 'CONTAINER'.  We use 'CONTAINER::value_type' for
    // everything, which means that if 'CONTAINER' is specified, then 'VALUE'
    // is ignored.

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
    // STATIC CHECK: Type mismatch is UB per C++17
    BSLMF_ASSERT((is_same<VALUE, typename CONTAINER::value_type>::value));
#endif

  private:
    // PRIVATE TYPES
    typedef BloombergLP::bslmf::MovableRefUtil  MoveUtil;
        // This 'typedef' is a convenient alias for the utility associated with
        // movable references.

  public:
    // PUBLIC TYPES
    typedef typename CONTAINER::value_type      value_type;
    typedef typename CONTAINER::reference       reference;
    typedef typename CONTAINER::const_reference const_reference;
    typedef typename CONTAINER::size_type       size_type;
    typedef          CONTAINER                  container_type;


  protected:
    // PROTECTED DATA
    container_type  c;    // We are required by the standard to have the
                          // container be a protected variable named 'c'.

  private:
    // FRIENDS
    template <class VAL, class CONT>
    friend bool operator==(const stack<VAL, CONT>&, const stack<VAL, CONT>&);
    template <class VAL, class CONT>
    friend bool operator!=(const stack<VAL, CONT>&, const stack<VAL, CONT>&);
    template <class VAL, class CONT>
    friend bool operator< (const stack<VAL, CONT>&, const stack<VAL, CONT>&);
    template <class VAL, class CONT>
    friend bool operator> (const stack<VAL, CONT>&, const stack<VAL, CONT>&);
    template <class VAL, class CONT>
    friend bool operator<=(const stack<VAL, CONT>&, const stack<VAL, CONT>&);
    template <class VAL, class CONT>
    friend bool operator>=(const stack<VAL, CONT>&, const stack<VAL, CONT>&);
#if defined BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON \
 && defined BSLS_LIBRARYFEATURES_HAS_CPP20_CONCEPTS
    template <class VAL, three_way_comparable CONT>
    friend compare_three_way_result_t<CONT>
    operator<=>(const stack<VAL, CONT>&, const stack<VAL, CONT>&);
#endif

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        stack,
        BloombergLP::bslma::UsesBslmaAllocator,
        BloombergLP::bslma::UsesBslmaAllocator<container_type>::value);

    // CREATORS
    explicit stack();
        // Create an empty stack.  No allocator will be provided to the
        // underlying container.  That container's memory allocation will be
        // provided by the default allocator of its type.

    stack(const stack& original);
        // Create a stack having the value of the specified 'original'.  The
        // currently installed default allocator is used to supply memory.

    stack(BloombergLP::bslmf::MovableRef<stack> original);
        // Create a stack having the value of the specified 'original' by
        // moving the contents of 'original' to the new stack.  The allocator
        // associated with 'original' is propagated for use in the new stack.
        // 'original' is left in a valid but unspecified state.

    explicit
    stack(const CONTAINER& container);
        // Create a stack whose underlying container has the value of the
        // specified 'container'.  The currently installed default allocator is
        // used to supply memory.

    explicit
    stack(BloombergLP::bslmf::MovableRef<CONTAINER> container);
        // Create a stack whose underlying container has the value of the
        // specified 'container' (on entry) by moving the contents of
        // 'container' to the new stack.  The allocator associated with
        // 'container' is propagated for use in the new stack.  'container' is
        // left in a valid but unspecified state.

    template <class ALLOCATOR>
    explicit
    stack(const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create an empty stack, and use the specified 'basicAllocator' to
        // supply memory.  If 'CONTAINER::allocator_type' does not exist, this
        // constructor may not be used.

    template <class ALLOCATOR>
    stack(const CONTAINER& container,
          const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a stack whose underlying container has the value of the
        // specified 'container', and use the specified 'basicAllocator' to
        // supply memory.  If 'CONTAINER::allocator_type' does not exist, this
        // constructor may not be used.

    template <class ALLOCATOR>
    stack(const stack&     original,
          const ALLOCATOR& basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a stack having the value of the specified stack 'original'
        // and use the specified 'basicAllocator' to supply memory.  If
        // 'CONTAINER::allocator_type' does not exist, this constructor may not
        // be used.

    template <class ALLOCATOR>
    stack(BloombergLP::bslmf::MovableRef<CONTAINER> container,
          const ALLOCATOR&                          basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a stack whose underlying container has the value of the
        // specified 'container' (on entry) that uses 'basicAllocator' to
        // supply memory by using the allocator-extended move constructor of
        // 'CONTAINER.  'container' is left in a valid but unspecified state.
        // A 'bslma::Allocator *' can be supplied for 'basicAllocator' if the
        // (template parameter) 'ALLOCATOR' is 'bsl::allocator' (the default).
        // This method assumes that 'CONTAINER' has a move constructor.  If
        // 'CONTAINER::allocator_type' does not exist, this constructor may not
        // be used.

    template <class ALLOCATOR>
    stack(BloombergLP::bslmf::MovableRef<stack> original,
          const ALLOCATOR&                      basicAllocator,
          typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                             ALLOCATOR>::type * = 0);
        // Create a stack having the value of the specified 'original' (on
        // entry) that uses 'basicAllocator' to supply memory by using the
        // allocator-extended moved constructor of 'CONTAINER'.  'original' is
        // left in a valid but unspecified state.  Note that a
        // 'bslma::Allocator *' can be supplied for 'basicAllocator' if the
        // (template parameter) 'ALLOCATOR' is 'bsl::allocator' (the default).
        // Also note that this method assumes that 'CONTAINER' has a move
        // constructor.  Also note that if 'CONTAINER::allocator_type' does not
        // exist, this constructor may not be used.

    // MANIPULATORS
    stack& operator=(const stack& rhs);
        // Assign to this object the value of the specified 'rhs' object, and
        // return a reference providing modifiable access to this object.

    stack& operator=(BloombergLP::bslmf::MovableRef<stack> rhs)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);
        // Assign to this object the value of the specified 'rhs' object, and
        // return a reference providing modifiable access to this object.  The
        // contents of 'rhs' are moved to this stack using the move-assignment
        // operator of 'CONTAINER'.  'rhs' is left in a valid but unspecified
        // state, and if an exception is thrown, '*this' is left in a valid but
        // unspecified state.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_stack.h
#ifndef BSLSTL_STACK_VARIADIC_LIMIT
#define BSLSTL_STACK_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_STACK_VARIADIC_LIMIT_A
#define BSLSTL_STACK_VARIADIC_LIMIT_A BSLSTL_STACK_VARIADIC_LIMIT
#endif
#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 0
    reference emplace();
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 0

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 1
    template <class Args_01>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 1

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 2
    template <class Args_01,
              class Args_02>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 2

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 3

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 4

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 5

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 6

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 7

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 8

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 9

#if BSLSTL_STACK_VARIADIC_LIMIT_A >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_A >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... Args>
    reference emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

// }}} END GENERATED CODE
#endif

    void pop();
        // Remove the top element from this stack.  The behavior is undefined
        // if this stack is empty.

    void push(const value_type& value);
        // Push the specified 'value' onto the top of this stack.

    void push(BloombergLP::bslmf::MovableRef<value_type> value);
        // Push onto this stack a 'value_type' object having the value of the
        // specified 'value' (on entry) by moving the contents of 'value' to
        // the new object on this stack.  'value' is left in a valid but
        // unspecified state.

    void swap(stack& other) BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                  bsl::is_nothrow_swappable<CONTAINER>::value);
        // Exchange the value of this stack with the value of the specified
        // 'other' stack.

    reference top();
        // Return a reference to the element at the top of this stack.  The
        // behavior is undefined if this stack is empty.

    // ACCESSORS
    bool empty() const;
        // Return 'true' if this stack contains no elements and 'false'
        // otherwise.

    size_type size() const;
        // Return the number of elements contained in this stack.

    const_reference top() const;
        // Return a reference providing non-modifiable access to the element at
        // the top of this stack.  The behavior is undefined if the stack is
        // empty.
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
// CLASS TEMPLATE DEDUCTION GUIDES

template<class CONTAINER,
         class = bsl::enable_if_t<!bsl::IsStdAllocator_v<CONTAINER>>
        >
stack(CONTAINER) -> stack<typename CONTAINER::value_type, CONTAINER>;
    // Deduce the template parameters 'VALUE' and 'CONTAINER' from the
    // parameters supplied to the constructor of 'stack'.  This deduction guide
    // does not participate if the parameter meets the requirements for a
    // standard allocator.

template<
    class CONTAINER,
    class ALLOCATOR,
    class = bsl::enable_if_t<bsl::uses_allocator_v<CONTAINER, ALLOCATOR>>
    >
stack(CONTAINER, ALLOCATOR) -> stack<typename CONTAINER::value_type, CONTAINER>;
    // Deduce the template parameters 'VALUE' and 'CONTAINER' from the
    // parameters supplied to the constructor of 'stack'.  This deduction
    // guide does not participate unless the supplied allocator is convertible
    // to the underlying container's 'allocator_type'.
#endif

// FREE OPERATORS
template <class VALUE, class CONTAINER>
bool operator==(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'stack' objects 'lhs' and 'rhs' have
    // the same value if they have the same number of elements, and each
    // element in the ordered sequence of elements of 'lhs' has the same value
    // as the corresponding element in the ordered sequence of elements of
    // 'rhs'.  This method requires that the (template parameter) type 'VALUE'
    // be 'equality-comparable' (see {Requirements on 'VALUE'}).

template <class VALUE, class CONTAINER>
bool operator!=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'stack' objects 'lhs' and 'rhs'
    // do not have the same value if they do not have the same number of
    // elements, or some element in the ordered sequence of elements of 'lhs'
    // does not have the same value as the corresponding element in the ordered
    // sequence of elements of 'rhs'.  This method requires that the (template
    // parameter) type 'VALUE' be 'equality-comparable' (see {Requirements on
    // 'VALUE'}).

template <class VALUE, class CONTAINER>
bool operator< (const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' stack is
    // lexicographically less than that of the specified 'rhs' stack, and
    // 'false' otherwise.  Given iterators 'i' and 'j' over the respective
    // sequences '[lhs.begin() .. lhs.end())' and '[rhs.begin() .. rhs.end())',
    // the value of stack 'lhs' is lexicographically less than that of stack
    // 'rhs' if 'true == *i < *j' for the first pair of corresponding iterator
    // positions where '*i < *j' and '*j < *i' are not both 'false'.  If no
    // such corresponding iterator position exists, the value of 'lhs' is
    // lexicographically less than that of 'rhs' if 'lhs.size() < rhs.size()'.
    // This method requires that 'operator<', inducing a total order, be
    // defined for 'value_type'.

template <class VALUE, class CONTAINER>
bool operator> (const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' stack is
    // lexicographically greater than that of the specified 'rhs' stack, and
    // 'false' otherwise.  The value of stack 'lhs' is lexicographically
    // greater than that of stack 'rhs' if 'rhs' is lexicographically less than
    // 'lhs' (see 'operator<').  This method requires that 'operator<',
    // inducing a total order, be defined for 'value_type'.  Note that this
    // operator returns 'rhs < lhs'.

template <class VALUE, class CONTAINER>
bool operator<=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' stack is
    // lexicographically less than or equal to that of the specified 'rhs'
    // stack, and 'false' otherwise.  The value of stack 'lhs' is
    // lexicographically less than or equal to that of stack 'rhs' if 'rhs' is
    // not lexicographically less than 'lhs' (see 'operator<').  This method
    // requires that 'operator<', inducing a total order, be defined for
    // 'value_type'.  Note that this operator returns '!(rhs < lhs)'.

template <class VALUE, class CONTAINER>
bool operator>=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs);
    // Return 'true' if the value of the specified 'lhs' stack is
    // lexicographically greater than or equal to that of the specified 'rhs'
    // stack, and 'false' otherwise.  The value of stack 'lhs' is
    // lexicographically greater than or equal to that of stack 'rhs' if 'lhs'
    // is not lexicographically less than 'rhs' (see 'operator<').  This method
    // requires that 'operator<', inducing a total order, be defined for
    // 'value_type'.  Note that this operator returns '!(lhs < rhs)'.

// FREE FUNCTIONS
template <class VALUE, class CONTAINER>
void swap(stack<VALUE, CONTAINER>& lhs,
          stack<VALUE, CONTAINER>& rhs)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);
    // Swap the value of the specified 'lhs' stack with the value of the
    // specified 'rhs' stack.

//=============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
//=============================================================================

                             // -----------
                             // class stack
                             // -----------

// CREATORS
template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>::stack()
: c()
{
}

template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>::stack(const CONTAINER& container)
: c(container)
{
}

template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>::stack(BloombergLP::bslmf::MovableRef<stack> original)
: c(MoveUtil::move(MoveUtil::access(original).c))
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
stack<VALUE, CONTAINER>::stack(const ALLOCATOR& basicAllocator,
           typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(basicAllocator)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
stack<VALUE, CONTAINER>::stack(
    const CONTAINER& container,
    const ALLOCATOR& basicAllocator,
    typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                       ALLOCATOR>::type *)
: c(container, basicAllocator)
{
}

template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>::stack(const stack& original)
: c(original.c)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
stack<VALUE, CONTAINER>::stack(
    const stack&     original,
    const ALLOCATOR& basicAllocator,
    typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                       ALLOCATOR>::type *)
: c(original.c, basicAllocator)
{
}

template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>::stack(BloombergLP::bslmf::MovableRef<CONTAINER>
                                                                     container)
: c(MoveUtil::move(container))
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
stack<VALUE, CONTAINER>::stack(
    BloombergLP::bslmf::MovableRef<CONTAINER> container,
    const ALLOCATOR&                          basicAllocator,
    typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                       ALLOCATOR>::type *)
: c(MoveUtil::move(container), basicAllocator)
{
}

template <class VALUE, class CONTAINER>
template <class ALLOCATOR>
inline
stack<VALUE, CONTAINER>::stack(
    BloombergLP::bslmf::MovableRef<stack> original,
    const ALLOCATOR&                      basicAllocator,
    typename enable_if<bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                       ALLOCATOR>::type *)
: c(MoveUtil::move(MoveUtil::access(original).c), basicAllocator)
{
}

// MANIPULATORS
template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>& stack<VALUE, CONTAINER>::operator=(const stack& rhs)
{
    c = rhs.c;

    return *this;
}

template <class VALUE, class CONTAINER>
inline
stack<VALUE, CONTAINER>& stack<VALUE, CONTAINER>::operator=(
                                     BloombergLP::bslmf::MovableRef<stack> rhs)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    c = MoveUtil::move(MoveUtil::access(rhs).c);
    return *this;
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_stack.h
#ifndef BSLSTL_STACK_VARIADIC_LIMIT
#define BSLSTL_STACK_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_STACK_VARIADIC_LIMIT_B
#define BSLSTL_STACK_VARIADIC_LIMIT_B BSLSTL_STACK_VARIADIC_LIMIT
#endif
#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 0
template <class VALUE, class CONTAINER>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                               )
{
    c.emplace_back();
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 0

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 1
template <class VALUE, class CONTAINER>
template <class Args_01>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 1

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 2
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 2

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 3
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 3

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 4
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 4

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 5
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 5

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 6
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 6

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 7
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 7

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 8
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 8

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 9
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 9

#if BSLSTL_STACK_VARIADIC_LIMIT_B >= 10
template <class VALUE, class CONTAINER>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09),
                   BSLS_COMPILERFEATURES_FORWARD(Args_10,args_10));
    return top();
}
#endif  // BSLSTL_STACK_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class VALUE, class CONTAINER>
template <class... Args>
inline
typename stack<VALUE, CONTAINER>::reference
stack<VALUE, CONTAINER>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
    return top();
}
// }}} END GENERATED CODE
#endif

template <class VALUE, class CONTAINER>
inline
void stack<VALUE, CONTAINER>::pop()
{
    BSLS_ASSERT_SAFE(!empty());

    c.pop_back();
}

template <class VALUE, class CONTAINER>
inline
void stack<VALUE, CONTAINER>::push(const value_type& value)
{
    c.push_back(value);
}

template <class VALUE, class CONTAINER>
inline
void stack<VALUE, CONTAINER>::push(BloombergLP::bslmf::MovableRef<value_type>
                                                                         value)
{
    c.push_back(MoveUtil::move(value));
}

template <class VALUE, class CONTAINER>
inline
void stack<VALUE, CONTAINER>::swap(stack& other)
    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                   bsl::is_nothrow_swappable<CONTAINER>::value)
{
    BloombergLP::bslalg::SwapUtil::swap(&c, &other.c);
}

template <class VALUE, class CONTAINER>
inline
typename CONTAINER::reference stack<VALUE, CONTAINER>::top()
{
    BSLS_ASSERT_SAFE(!empty());

    return c.back();
}

// ACCESSORS
template <class VALUE, class CONTAINER>
inline
bool stack<VALUE, CONTAINER>::empty() const
{
    return 0 == c.size();
}

template <class VALUE, class CONTAINER>
inline
typename CONTAINER::size_type stack<VALUE, CONTAINER>::size() const
{
    return c.size();
}

template <class VALUE, class CONTAINER>
inline
typename CONTAINER::const_reference stack<VALUE, CONTAINER>::top() const
{
    return c.back();
}

// FREE OPERATORS
template <class VALUE, class CONTAINER>
inline
bool operator==(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c == rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator!=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c != rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator< (const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c < rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator> (const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c > rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator<=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c <= rhs.c;
}

template <class VALUE, class CONTAINER>
inline
bool operator>=(const stack<VALUE, CONTAINER>& lhs,
                const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c >= rhs.c;
}

#if defined BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON \
 && defined BSLS_LIBRARYFEATURES_HAS_CPP20_CONCEPTS
template <class VALUE, three_way_comparable CONTAINER>
inline compare_three_way_result_t<CONTAINER>
operator<=>(const stack<VALUE, CONTAINER>& lhs,
            const stack<VALUE, CONTAINER>& rhs)
{
    return lhs.c <=> rhs.c;
}
#endif

// FREE FUNCTIONS
template <class VALUE, class CONTAINER>
inline
void swap(stack<VALUE, CONTAINER>& lhs,
          stack<VALUE, CONTAINER>& rhs)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    lhs.swap(rhs);
}

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLSTL_STACK_H)
# error Not valid except when included from bslstl_stack.h
#endif // ! defined(COMPILING_BSLSTL_STACK_H)

#endif // ! defined(INCLUDED_BSLSTL_STACK_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
