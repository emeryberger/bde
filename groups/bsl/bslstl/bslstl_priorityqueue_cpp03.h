// bslstl_priorityqueue_cpp03.h                                       -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_PRIORITYQUEUE_CPP03
#define INCLUDED_BSLSTL_PRIORITYQUEUE_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_priorityqueue.h
//
//@CLASSES: See bslstl_priorityqueue.h for list of classes
//
//@SEE_ALSO: bslstl_priorityqueue
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Wed Dec  7 18:22:06 2022
// Command line: sim_cpp11_features.pl bslstl_priorityqueue.h

#ifdef COMPILING_BSLSTL_PRIORITYQUEUE_H

namespace bsl {

                         // ====================
                         // class priority_queue
                         // ====================

template <class VALUE,
          class CONTAINER  = vector<VALUE>,
          class COMPARATOR = std::less<typename CONTAINER::value_type> >
class priority_queue {
    // This class is a value-semantic class template, adapting a container of
    // the (template parameter) type 'CONTAINER', that holds elements of the
    // (template parameter) type 'VALUE', to provide a highest-priority-first
    // priority queue data structure, where the priorities of elements are
    // compared by a comparator of the template parameter type, 'COMPARATOR'.
    // The container object held by a 'priority_queue' class object is
    // referenced as 'c' in the following documentation.

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
    // STATIC CHECK: Type mismatch is UB per C++17
    BSLMF_ASSERT((is_same<VALUE, typename CONTAINER::value_type>::value));
#endif

  private:
    // PRIVATE TYPES
    typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;
        // This 'typedef' is a convenient alias for the utility associated with
        // movable references.

  public:
    // PUBLIC TYPES
    typedef          CONTAINER                  container_type;
    typedef          COMPARATOR                 value_compare;
    typedef typename CONTAINER::value_type      value_type;
    typedef typename CONTAINER::reference       reference;
    typedef typename CONTAINER::const_reference const_reference;
    typedef typename CONTAINER::size_type       size_type;

  protected:
    // PROTECTED DATA
    CONTAINER  c;     // container for elements in the 'priority_queue'.  This
                      // data member exactly matches its definition in the
                      // C++11 standard [23.6.4].

    COMPARATOR comp;  // comparator that defines the priority order of elements
                      // in the 'priority_queue'.  This data member exactly
                      // matches its definition in the C++11 standard [23.6.4].

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        priority_queue,
        BloombergLP::bslma::UsesBslmaAllocator,
        BloombergLP::bslma::UsesBslmaAllocator<container_type>::value);

    // CREATORS
    priority_queue();
        // Create an empty priority queue, adapting a default-constructed
        // container of the (template parameter) type 'CONTAINER'.  Use a
        // default-constructed comparator of the (template parameter) type
        // 'COMPARATOR' to order elements in the priority queue.

    explicit priority_queue(const COMPARATOR& comparator);
        // Create an empty priority queue, adapting a default-constructed
        // container of the (template parameter) type 'CONTAINER', and having
        // the specified 'comparator' of the (template parameter) type
        // 'COMPARATOR' to order elements in the priority queue.

    priority_queue(const COMPARATOR& comparator, const CONTAINER& container);
        // Create a priority queue, adapting the specified 'container' of the
        // (template parameter) type 'CONTAINER', and having the specified
        // 'comparator' of the (template parameter) type 'COMPARATOR' to order
        // elements in the priority queue.

    explicit priority_queue(
           const COMPARATOR&                         comparator,
           BloombergLP::bslmf::MovableRef<CONTAINER> container);
        // Create a priority queue, adapting the specified 'container' of the
        // (template parameter) type 'CONTAINER', and having the specified
        // 'comparator' of the (template parameter) type 'COMPARATOR' to order
        // elements in the priority queue.


    template <class INPUT_ITERATOR>
    priority_queue(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Create a priority queue, adapting a default-constructed container of
        // the (template parameter) type 'CONTAINER', and inserting into the
        // container a sequence of 'value_type' elements that starts at the
        // specified 'first' and ends immediately before the specified 'last'.
        // Use a default-constructed comparator of the (template parameter)
        // type 'COMPARATOR' to order elements in the priority queue.

    template <class INPUT_ITERATOR>
    priority_queue(INPUT_ITERATOR    first,
                   INPUT_ITERATOR    last,
                   const COMPARATOR& comparator,
                   const CONTAINER&  container);
        // Create a priority queue, adapting the specified 'container', having
        // the specified 'comparator' to order the priorities of elements,
        // including those originally existed in 'container', and those
        // inserted into the 'container' from a sequence of 'value_type'
        // elements starting at the specified 'first', and ending immediately
        // before the specified 'last'.

    template <class INPUT_ITERATOR>
    priority_queue(
           INPUT_ITERATOR                            first,
           INPUT_ITERATOR                            last,
           const COMPARATOR&                         comparator,
           BloombergLP::bslmf::MovableRef<CONTAINER> container);
        // Create a priority queue, adapting the specified 'container', having
        // the specified 'comparator' to order elements in the priority queue,
        // including those originally existed in 'container', and those
        // inserted into the 'container' from a sequence of 'value_type'
        // elements starting at the specified 'first', and ending immediately
        // before the specified 'last'.

    priority_queue(const priority_queue& original);
        // Create a priority queue having the same value as the specified
        // 'original' object.  Use a copy of the comparator from 'original' to
        // order elements in the priority queue.

    priority_queue(BloombergLP::bslmf::MovableRef<priority_queue> original);
        // Create a priority queue having the same value as the specified
        // 'original' object.  Use a copy of the comparator from 'original' to
        // order elements in the priority queue.

    template <class ALLOCATOR>
    explicit
    priority_queue(const ALLOCATOR& basicAllocator,
                   typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create an empty priority queue, adapting a default-constructed
        // container of the (template parameter) type 'CONTAINER' that uses the
        // specified 'basicAllocator' to supply memory.  Use a
        // default-constructed object of the (template parameter) type
        // 'COMPARATOR' to order elements in the priority queue.  Note that
        // this constructor is only defined if the underlying container uses
        // allocator.  Otherwise this constructor is disabled.

    template <class ALLOCATOR>
    priority_queue(const COMPARATOR& comparator,
                   const ALLOCATOR&  basicAllocator,
                   typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create an empty priority queue, adapting a default-constructed
        // container of the (template parameter) type 'CONTAINER' that uses the
        // specified 'basicAllocator' to supply memory, and the specified
        // 'comparator' to order elements in the priority queue.  Note that
        // this constructor is only defined if the underlying container uses
        // allocator.  Otherwise this constructor is disabled.

    template <class ALLOCATOR>
    priority_queue(const COMPARATOR& comparator,
                   const CONTAINER&  container,
                   const ALLOCATOR&  basicAllocator,
                   typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create a priority queue, adapting the specified 'container' that
        // uses the specified 'basicAllocator' to supply memory, and the
        // specified 'comparator' to order elements in the priority queue.
        // Note that this constructor is only defined if the underlying
        // container uses allocator.  Otherwise this constructor is disabled.

    template <class ALLOCATOR>
    priority_queue(const COMPARATOR&                         comparator,
                   BloombergLP::bslmf::MovableRef<CONTAINER> container,
                   const ALLOCATOR&                          basicAllocator,
                   typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create a priority queue, adapting the specified 'container' that
        // uses the specified 'basicAllocator' to supply memory, and the
        // specified 'comparator' to order elements in the priority queue.
        // Note that this constructor is only defined if the underlying
        // container uses allocator.  Otherwise this constructor is disabled.

    template <class ALLOCATOR>
    priority_queue(const priority_queue& original,
                   const ALLOCATOR&      basicAllocator,
                   typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create a priority queue having the same value as the specified
        // 'original' object and using the specified 'basicAllocator' to supply
        // memory.  Use a copy of the comparator from 'original' to order
        // elements in the priority queue.  Note that this constructor is only
        // defined if the underlying container uses allocator.  Otherwise this
        // constructor is disabled.

    template <class ALLOCATOR>
    priority_queue(
                 BloombergLP::bslmf::MovableRef<priority_queue> original,
                 const ALLOCATOR&                               basicAllocator,
                 typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type * = 0);
        // Create a priority queue having the same value as the specified
        // 'original' object and using the specified 'basicAllocator' to supply
        // memory.  Use a copy of the comparator from 'original' to order
        // elements in the priority queue.  Note that this constructor is only
        // defined if the underlying container uses allocator.  Otherwise this
        // constructor is disabled.

    // MANIPULATORS
    priority_queue& operator=(const priority_queue& rhs);
        // Assign to this object the value and comparator of the specified
        // 'rhs' object and return a reference providing modifiable access to
        // this object.

    priority_queue& operator=(
                            BloombergLP::bslmf::MovableRef<priority_queue> rhs)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);
        // Assign to this object the value and comparator of the specified
        // 'rhs' object and return a reference providing modifiable access to
        // this object.  'rhs' is left in a valid but unspecified state.

    void push(const value_type& value);
        // Insert the specified 'value' into this priority queue.  In effect,
        // performs 'c.push_back(value);'.

    void push(BloombergLP::bslmf::MovableRef<value_type> value);
        // Insert the specified 'value' into this priority queue.  In effect,
        // performs 'c.push_back(value);'.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_priorityqueue.h
#ifndef BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT
#define BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A
#define BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT
#endif
#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 0
    void emplace();
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 0

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 1
    template <class Args_01>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 1

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 2
    template <class Args_01,
              class Args_02>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 2

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 3

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 4

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 5

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 6

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 7

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 8

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 9

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                 BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_A >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... Args>
    void emplace(BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
// }}} END GENERATED CODE
#endif

    void pop();
        // Remove the top element from this 'priority_queue' object that has
        // the highest priority.  In effect, performs 'c.pop_back();'.  The
        // behavior is undefined if there is currently no elements in this
        // object.

    void swap(priority_queue& other) BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                 bsl::is_nothrow_swappable<CONTAINER>::value &&
                                 bsl::is_nothrow_swappable<COMPARATOR>::value);
        // Efficiently exchange the value of this object with the value of the
        // specified 'other' object.  In effect, performs 'using bsl::swap;
        // swap(c, other.c);'.

    // ACCESSORS
    bool empty() const;
        // Return 'true' if this 'priority_queue' object contains no elements,
        // and 'false' otherwise.  In effect, performs 'return c.empty();'.

    size_type size() const;
        // Return the number of elements in this 'priority_queue' object.  In
        // effect, performs 'return c.size()'.

    const_reference top() const;
        // Return a reference providing non-modifiable access to the element
        // having the highest priority in this 'priority_queue' object.  In
        // effect, performs 'return c.front()'.  The behavior is undefined if
        // the priority queue is empty.
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
// CLASS TEMPLATE DEDUCTION GUIDES

template <
    class COMPARATOR,
    class CONTAINER,
    class = bsl::enable_if_t<!bsl::IsStdAllocator_v<CONTAINER>>
    >
priority_queue(COMPARATOR, CONTAINER)
  -> priority_queue<typename CONTAINER::value_type, CONTAINER, COMPARATOR>;
    // Deduce the template parameter 'VALUE' and 'CONTAINER' from the
    // parameters supplied to the constructor of 'priority_queue'.

template <
    class COMPARATOR,
    class CONTAINER,
    class ALLOCATOR,
    class = bsl::enable_if_t<bsl::uses_allocator_v<CONTAINER, ALLOCATOR>>
    >
priority_queue(COMPARATOR, CONTAINER, ALLOCATOR)
  -> priority_queue<typename CONTAINER::value_type, CONTAINER, COMPARATOR>;
    // Deduce the template parameters 'VALUE', 'CONTAINER' and 'COMPARATOR'
    // from the parameters supplied to the constructor of 'priority_queue'.
    // This deduction guide does not participate unless the supplied allocator
    // is convertible to the underlying container's 'allocator_type'.

template <
    class INPUT_ITERATOR,
    class VALUE =
          typename BloombergLP::bslstl::IteratorUtil::IterVal_t<INPUT_ITERATOR>
    >
priority_queue(INPUT_ITERATOR, INPUT_ITERATOR)
  -> priority_queue<VALUE>;
    // Deduce the template parameter 'VALUE' from the 'value_type' of the
    // iterators supplied to the constructor of 'priority_queue'.

template <
    class INPUT_ITERATOR,
    class COMPARATOR,
    class CONTAINER,
    class VALUE =
          typename BloombergLP::bslstl::IteratorUtil::IterVal_t<INPUT_ITERATOR>
    >
priority_queue(INPUT_ITERATOR, INPUT_ITERATOR, COMPARATOR, CONTAINER)
  -> priority_queue<VALUE, CONTAINER, COMPARATOR>;
    // Deduce the template parameter 'VALUE' from the 'value_type' of the
    // iterators supplied to the constructor of 'priority_queue'.  Deduce the
    // template parameters 'CONTAINER' and 'COMPARATOR' from the other
    // parameters passed to the constructor.
#endif

// FREE FUNCTIONS
template <class VALUE, class CONTAINER, class COMPARATOR>
void swap(priority_queue<VALUE, CONTAINER, COMPARATOR>& a,
          priority_queue<VALUE, CONTAINER, COMPARATOR>& b)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);
    // Exchange the container and comparator of the specified 'a' object with
    // the container and comparator of the specified 'b' object.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                         // --------------------
                         // class priority_queue
                         // --------------------

// CREATORS
template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue()
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                                                  const COMPARATOR& comparator)
: comp(comparator)
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                                                  const COMPARATOR& comparator,
                                                  const CONTAINER&  container)
: c(container)
, comp(comparator)
{
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                          const COMPARATOR&                         comparator,
                          BloombergLP::bslmf::MovableRef<CONTAINER> container)
: c(MoveUtil::move(container))
, comp(comparator)
{
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class INPUT_ITERATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                                                       INPUT_ITERATOR    first,
                                                       INPUT_ITERATOR    last)
{
    c.insert(c.end(), first, last);
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class INPUT_ITERATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                                                  INPUT_ITERATOR    first,
                                                  INPUT_ITERATOR    last,
                                                  const COMPARATOR& comparator,
                                                  const CONTAINER&  container)
: c(container)
, comp(comparator)
{
    c.insert(c.end(), first, last);
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class INPUT_ITERATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                         INPUT_ITERATOR                             first,
                         INPUT_ITERATOR                             last,
                         const COMPARATOR&                          comparator,
                         BloombergLP::bslmf::MovableRef<CONTAINER>  container)
: c(MoveUtil::move(container))
, comp(comparator)
{
    c.insert(c.end(), first, last);
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                                                const priority_queue& original)
: c(original.c)
, comp(original.comp)
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                       BloombergLP::bslmf::MovableRef<priority_queue> original)
: c(MoveUtil::move(MoveUtil::access(original).c))
, comp(MoveUtil::access(original).comp)
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                          const ALLOCATOR& basicAllocator,
                          typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(basicAllocator)
, comp(COMPARATOR())
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                          const COMPARATOR& comparator,
                          const ALLOCATOR&  basicAllocator,
                          typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(basicAllocator)
, comp(comparator)
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                          const COMPARATOR& comparator,
                          const CONTAINER&  container,
                          const ALLOCATOR&  basicAllocator,
                          typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(container, basicAllocator)
, comp(comparator)
{
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                      const COMPARATOR&                         comparator,
                      BloombergLP::bslmf::MovableRef<CONTAINER> container,
                      const ALLOCATOR&                          basicAllocator,
                      typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(MoveUtil::move(container), basicAllocator)
, comp(comparator)
{
    std::make_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                          const priority_queue& original,
                          const ALLOCATOR&      basicAllocator,
                          typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(original.c, basicAllocator)
, comp(original.comp)
{
}

template <class VALUE, class CONTAINER, class COMPARATOR>
template <class ALLOCATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>::priority_queue(
                 BloombergLP::bslmf::MovableRef<priority_queue> original,
                 const ALLOCATOR&                               basicAllocator,
                 typename enable_if<
                              bsl::uses_allocator<CONTAINER, ALLOCATOR>::value,
                              ALLOCATOR>::type *)
: c(MoveUtil::move(MoveUtil::access(original).c), basicAllocator)
, comp(MoveUtil::access(original).comp)
{
}

// MANIPULATORS
template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>&
priority_queue<VALUE, CONTAINER, COMPARATOR>::operator=(
                                                     const priority_queue& rhs)
{
    c = rhs.c;
    comp = rhs.comp;
    return *this;
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
priority_queue<VALUE, CONTAINER, COMPARATOR>&
priority_queue<VALUE, CONTAINER, COMPARATOR>::operator=(
                            BloombergLP::bslmf::MovableRef<priority_queue> rhs)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    c = MoveUtil::move(MoveUtil::access(rhs).c);
    comp = MoveUtil::access(rhs).comp;
    return *this;
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::push(
                                                       const value_type& value)
{
    c.push_back(value);
    std::push_heap(c.begin(), c.end(), comp);
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::push(
                              BloombergLP::bslmf::MovableRef<value_type> value)
{
    c.push_back(MoveUtil::move(value));
    std::push_heap(c.begin(), c.end(), comp);
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_priorityqueue.h
#ifndef BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT
#define BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B
#define BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT
#endif
#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 0
template <class VALUE, class CONTAINER, class COMPARATOR>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                               )
{
    c.emplace_back();
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 0

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 1
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 1

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 2
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 2

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 3
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 3

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 4
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 4

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 5
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 5

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 6
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 6

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 7
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 7

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 8
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 8

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 9
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 9

#if BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 10
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args_01,args_01),
                   BSLS_COMPILERFEATURES_FORWARD(Args_02,args_02),
                   BSLS_COMPILERFEATURES_FORWARD(Args_03,args_03),
                   BSLS_COMPILERFEATURES_FORWARD(Args_04,args_04),
                   BSLS_COMPILERFEATURES_FORWARD(Args_05,args_05),
                   BSLS_COMPILERFEATURES_FORWARD(Args_06,args_06),
                   BSLS_COMPILERFEATURES_FORWARD(Args_07,args_07),
                   BSLS_COMPILERFEATURES_FORWARD(Args_08,args_08),
                   BSLS_COMPILERFEATURES_FORWARD(Args_09,args_09),
                   BSLS_COMPILERFEATURES_FORWARD(Args_10,args_10));
    std::push_heap(c.begin(), c.end(), comp);
}
#endif  // BSLSTL_PRIORITYQUEUE_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class VALUE, class CONTAINER, class COMPARATOR>
template <class... Args>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    c.emplace_back(BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
    std::push_heap(c.begin(), c.end(), comp);
}
// }}} END GENERATED CODE
#endif

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::pop()
{
    std::pop_heap(c.begin(), c.end(), comp);
    c.pop_back();
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
void priority_queue<VALUE, CONTAINER, COMPARATOR>::swap(priority_queue& other)
    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                 bsl::is_nothrow_swappable<CONTAINER>::value &&
                                 bsl::is_nothrow_swappable<COMPARATOR>::value)
{
    BloombergLP::bslalg::SwapUtil::swap(&c, &other.c);
    BloombergLP::bslalg::SwapUtil::swap(&comp, &other.comp);
}

// ACCESSORS
template <class VALUE, class CONTAINER, class COMPARATOR>
inline
bool priority_queue<VALUE, CONTAINER, COMPARATOR>::empty() const
{
    return c.empty();
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
typename priority_queue<VALUE, CONTAINER, COMPARATOR>::size_type
priority_queue<VALUE, CONTAINER, COMPARATOR>::size() const
{
    return c.size();
}

template <class VALUE, class CONTAINER, class COMPARATOR>
inline
typename priority_queue<VALUE, CONTAINER, COMPARATOR>::const_reference
priority_queue<VALUE, CONTAINER, COMPARATOR>::top() const
{
    return c.front();
}

// FREE FUNCTIONS
template <class VALUE, class CONTAINER, class COMPARATOR>
void swap(priority_queue<VALUE, CONTAINER, COMPARATOR>& a,
          priority_queue<VALUE, CONTAINER, COMPARATOR>& b)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    a.swap(b);
}

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLSTL_PRIORITYQUEUE_H)
# error Not valid except when included from bslstl_priorityqueue.h
#endif // ! defined(COMPILING_BSLSTL_PRIORITYQUEUE_H)

#endif // ! defined(INCLUDED_BSLSTL_PRIORITYQUEUE_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2022 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
