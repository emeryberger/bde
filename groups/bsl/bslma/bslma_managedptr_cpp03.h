// bslma_managedptr_cpp03.h                                           -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_MANAGEDPTR_CPP03
#define INCLUDED_BSLMA_MANAGEDPTR_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_managedptr.h
//
//@CLASSES: See bslma_managedptr.h for list of classes
//
//@SEE_ALSO: bslma_managedptr
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Mon Oct 17 10:42:50 2022
// Command line: sim_cpp11_features.pl bslma_managedptr.h

#ifdef COMPILING_BSLMA_MANAGEDPTR_H

namespace BloombergLP {
namespace bslma {

                  // =================================
                  // private struct ManagedPtr_ImpUtil
                  // =================================

struct ManagedPtr_ImpUtil {
    // This 'struct' provides a namespace for utility functions used to obtain
    // the necessary types of pointers.

    // CLASS METHODS
    template <class TYPE>
    static void *voidify(TYPE *address) BSLS_KEYWORD_NOEXCEPT;
        // Return the specified 'address' cast as a pointer to 'void', even if
        // (the template parameter) 'TYPE' is cv-qualified.

    template <class TYPE>
    static TYPE *unqualify(const volatile TYPE *address) BSLS_KEYWORD_NOEXCEPT;
        // Return the specified 'address' of a potentially cv-qualified object
        // of the given (template parameter) 'TYPE', cast as a pointer to
        // non-cv-qualified 'TYPE'.
};
                    // ============================
                    // private class ManagedPtr_Ref
                    // ============================

template <class TARGET_TYPE>
class ManagedPtr_Ref {
    // This class holds a managed pointer reference, returned by the implicit
    // conversion operator in the class 'ManagedPtr'.  This class is used to
    // allow the construction of managed pointers from temporary managed
    // pointer objects, since temporaries cannot bind to the reference to a
    // modifiable object used in the copy constructor and copy-assignment
    // operator for 'ManagedPtr'.  Note that while no members or methods of
    // this class template depend on the specified 'TARGET_TYPE', it is
    // important to carry this type into conversions to support passing
    // ownership of 'ManagedPtr_Members' pointers when assigning or
    // constructing 'ManagedPtr' objects.

    // DATA
    ManagedPtr_Members *d_base_p;  // non-null pointer to the managed state of
                                   // a 'ManagedPtr' object

    TARGET_TYPE        *d_cast_p;  // safely-cast pointer to the referenced
                                   // object

  public:
    // CREATORS
    ManagedPtr_Ref(ManagedPtr_Members *base, TARGET_TYPE *target);
        // Create a 'ManagedPtr_Ref' object having the specified 'base' value
        // for its 'base' attribute, and the specified 'target' for its
        // 'target' attribute.  Note that 'target' (but not 'base') may be
        // null.

    //! ManagedPtr_Ref(const ManagedPtr_Ref& original) = default;
        // Create a 'ManagedPtr_Ref' object having the same 'd_base_p' value as
        // the specified 'original'.  Note that this trivial constructor's
        // definition is compiler generated.

    ~ManagedPtr_Ref();
        // Destroy this object.  Note that the referenced managed object is
        // *not* destroyed.

    // MANIPULATORS
    //! ManagedPtr_Ref& operator=(const ManagedPtr_Ref& original) = default;
        // Create a 'ManagedPtr_Ref' object having the same 'd_base_p' as the
        // specified 'original'.  Note that this trivial copy-assignment
        // operator's definition is compiler generated.

    // ACCESSORS
    ManagedPtr_Members *base() const;
        // Return a pointer to the managed state of a 'ManagedPtr' object.

    TARGET_TYPE *target() const;
        // Return a pointer to the referenced object.
};

                    // =========================================
                    // private struct ManagedPtr_TraitConstraint
                    // =========================================

struct ManagedPtr_TraitConstraint {
    // This 'struct' is an empty type that exists solely to enable constructor
    // access to be constrained by type trait.
};
                           // ================
                           // class ManagedPtr
                           // ================

template <class TARGET_TYPE>
class ManagedPtr {
    // This class is a "smart pointer" that refers to a *target* object
    // accessed via a pointer to the specified parameter type, 'TARGET_TYPE',
    // and that supports sole ownership of a *managed* object that is
    // potentially of a different type, and may be an entirely different object
    // from the target object.  A managed pointer ensures that the object it
    // manages is destroyed when the managed pointer is destroyed (or
    // re-assigned), using the "deleter" supplied along with the managed
    // object.  The target object referenced by a managed pointer may be
    // accessed using either the '->' operator, or the dereference operator
    // ('operator *').  The specified 'TARGET_TYPE' may be 'const'-qualified,
    // but may not be 'volatile'-qualified, nor may it be a reference type.
    //
    // A managed pointer may be *empty*, in which case it neither refers to a
    // target object nor owns a managed object.  An empty managed pointer is
    // the equivalent of a null pointer: Such a managed pointer is not
    // de-referenceable, and tests as 'false' in boolean expressions.
    //
    // A managed pointer for which the managed object is not the same object as
    // the target is said to *alias* the managed object (see the section
    // "Aliasing" in the component-level documentation).

  public:
    // INTERFACE TYPES
    typedef ManagedPtrDeleter::Deleter DeleterFunc;
        // Alias for a function-pointer type for functions used to destroy the
        // object managed by a 'ManagedPtr' object.

    typedef TARGET_TYPE element_type;
        // Alias to the 'TARGET_TYPE' template parameter.

  private:
    // PRIVATE TYPES
    typedef typename bsls::UnspecifiedBool<ManagedPtr>::BoolType BoolType;
        // 'BoolType' is an alias for an unspecified type that is implicitly
        // convertible to 'bool', but will not promote to 'int'.  This (opaque)
        // type can be used as an "unspecified boolean type" for converting a
        // managed pointer to 'bool' in contexts such as 'if (mp) { ... }'
        // without actually having a conversion to 'bool' or being less-than
        // comparable (either of which would also enable undesirable implicit
        // comparisons of managed pointers to 'int' and less-than comparisons).

    typedef bslmf::MovableRefUtil                                MoveUtil;
        // This 'typedef' is a convenient alias for the utility associated with
        // movable references.

    // DATA
    ManagedPtr_Members d_members;  // state managed by this object

    // PRIVATE CLASS METHODS
    static void *stripBasePointerType(TARGET_TYPE *ptr);
        // Return the value of the specified 'ptr' as a 'void *', after
        // stripping all 'const' and 'volatile' qualifiers from 'TARGET_TYPE'.
        // This function avoids accidental type-safety errors when performing
        // the necessary sequence of casts.  Note that calling this function
        // implies a conversion of the calling pointer to 'TARGET_TYPE *',
        // which, in rare cases, may involve some adjustment of the pointer
        // value, e.g., in the case of multiple inheritance where 'TARGET_TYPE'
        // is not a left-most base of the complete object type.

    template <class MANAGED_TYPE>
    static void *stripCompletePointerType(MANAGED_TYPE *ptr);
        // Return the value of the specified 'ptr' as a 'void *', after
        // stripping all 'const' and 'volatile' qualifiers from 'MANAGED_TYPE'.
        // This function avoids accidental type-safety errors when performing
        // the necessary sequence of casts.

    // PRIVATE MANIPULATORS
    template <class MANAGED_TYPE>
    void loadImp(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified 'ptr', take ownership of '*ptr' as the currently managed
        // object, and set a deleter that will invoke the specified 'deleter'
        // with the address of the currently managed object, and with the
        // specified 'cookie' (that the deleter can use for its own purposes),
        // unless '0 == ptr', in which case reset this managed pointer to
        // empty.  The behavior is undefined if 'ptr' is already managed by
        // another object, or if '0 == deleter && 0 != ptr'.

  private:
    // NOT IMPLEMENTED
    template <class MANAGED_TYPE>
    ManagedPtr(MANAGED_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null pointer literal as a
        // factory, unless the specified 'ptr' is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    template <class MANAGED_TYPE, class COOKIE_TYPE>
    ManagedPtr(MANAGED_TYPE *, COOKIE_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null literal as a deleter,
        // unless the 'object' pointer is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    template <class MANAGED_TYPE>
    void load(MANAGED_TYPE *, bsl::nullptr_t, bsl::nullptr_t);
    template <class COOKIE_TYPE>
    void load(TARGET_TYPE *, COOKIE_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null literal as a deleter,
        // unless the 'object' pointer is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    void operator==(const ManagedPtr&) const;
    void operator!=(const ManagedPtr&) const;
        // These two operator overloads are declared as 'private' but never
        // defined in order to eliminate accidental equality comparisons that
        // would occur through the implicit conversion to 'BoolType'.  Note
        // that the return type of 'void' is chosen as it will often produce a
        // clearer error message than relying on the 'private' control failure.
        // Also note that these private operators will not be needed with
        // C++11, where an 'explicit operator bool()' conversion operator would
        // be preferred.

    // FRIENDS
    template <class ALIASED_TYPE>
    friend class ManagedPtr;  // required only for alias support

  public:
    // CREATORS
    ManagedPtr();
        // Create an empty managed pointer.

    template <class MANAGED_TYPE>
    explicit ManagedPtr(MANAGED_TYPE *ptr);
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will call 'delete ptr' to destroy the managed object
        // when invoked (e.g., when this managed pointer object is destroyed),
        // unless '0 == ptr', in which case create an empty managed pointer.
        // The deleter will invoke the destructor of 'MANAGED_TYPE' rather than
        // the destructor of 'TARGET_TYPE'.  This constructor will not compile
        // unless 'MANAGED_TYPE *' is convertible to 'TARGET_TYPE *'.  Note
        // that this behavior allows 'ManagedPtr' to be defined for 'void'
        // pointers, and to call the correct destructor for the managed object,
        // even if the destructor for 'TARGET_TYPE' is not declared as
        // 'virtual'.  The behavior is undefined unless the managed object (if
        // any) can be destroyed by 'delete', or if the lifetime of the managed
        // object is already managed by another object.

    ManagedPtr(ManagedPtr_Ref<TARGET_TYPE> ref)
                                             BSLS_KEYWORD_NOEXCEPT; // IMPLICIT
        // Create a managed pointer having the same target object as the
        // managed pointer referenced by the specified 'ref', transfer
        // ownership of the managed object owned by the managed pointer
        // referenced by 'ref', and reset the managed pointer referenced by
        // 'ref' to empty.  This constructor is used to create a managed
        // pointer from a managed pointer rvalue, or from a managed pointer to
        // a "compatible" type, where "compatible" means a built-in conversion
        // from 'COMPATIBLE_TYPE *' to 'TARGET_TYPE *' is defined, e.g.,
        // 'derived *' to 'base *', 'T *' to 'const T *', or 'T *' to 'void *'.

    ManagedPtr(ManagedPtr& original)                   BSLS_KEYWORD_NOEXCEPT;
    ManagedPtr(bslmf::MovableRef<ManagedPtr> original) BSLS_KEYWORD_NOEXCEPT;
        // Create a managed pointer having the same target object as the
        // specified 'original', transfer ownership of the object managed by
        // 'original' (if any) to this managed pointer, and reset 'original' to
        // empty.

#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    template <class BDE_OTHER_TYPE>
    ManagedPtr(ManagedPtr<BDE_OTHER_TYPE>&& original,
               typename bsl::enable_if<
                   bsl::is_convertible<BDE_OTHER_TYPE *, TARGET_TYPE *>::value,
                   ManagedPtr_TraitConstraint>::type =
                       ManagedPtr_TraitConstraint())
        BSLS_KEYWORD_NOEXCEPT;
#elif defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    // sun compiler version 12.3 and earlier
    template <class BDE_OTHER_TYPE>
    ManagedPtr(bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > original)
        BSLS_KEYWORD_NOEXCEPT;
#else // c++03 except old (version <= 12.3) sun compilers
    template <class BDE_OTHER_TYPE>
    ManagedPtr(bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > original,
               typename bsl::enable_if<
                 bsl::is_convertible<BDE_OTHER_TYPE *, TARGET_TYPE *>::value,
                 ManagedPtr_TraitConstraint>::type =
                     ManagedPtr_TraitConstraint())
        BSLS_KEYWORD_NOEXCEPT;
#endif
        // Create a managed pointer having the same target object as the
        // specified 'original', transfer ownership of the object managed by
        // 'original' (if any) to this managed pointer, and reset 'original' to
        // empty.  'TARGET_TYPE' must be an accessible and unambiguous base of
        // 'BDE_OTHER_TYPE'

    template <class ALIASED_TYPE>
    ManagedPtr(ManagedPtr<ALIASED_TYPE>& alias, TARGET_TYPE *ptr);
    template <class ALIASED_TYPE>
#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    ManagedPtr(ManagedPtr<ALIASED_TYPE>&&                    alias,
#else
    ManagedPtr(bslmf::MovableRef<ManagedPtr<ALIASED_TYPE> >  alias,
#endif
               TARGET_TYPE                                  *ptr);
        // Create a managed pointer that takes ownership of the object managed
        // by the specified 'alias', but which uses the specified 'ptr' to
        // refer to its target object, unless '0 == ptr', in which case create
        // an empty managed pointer.  Reset 'alias' to empty if ownership of
        // its managed object is transferred.  The behavior is undefined if
        // 'alias' is empty, but '0 != ptr'.  Note that destroying or
        // re-assigning a managed pointer created with this constructor will
        // destroy the object originally managed by 'alias' (unless 'release'
        // is called first); the destructor for '*ptr' is not called directly.

    template <class MANAGED_TYPE, class FACTORY_TYPE>
    ManagedPtr(MANAGED_TYPE *ptr, FACTORY_TYPE *factory);
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will call 'factory->deleteObject(ptr)' to destroy the
        // managed object when invoked (e.g., when this managed pointer object
        // is destroyed), unless '0 == ptr', in which case create an empty
        // managed pointer.  The deleter will invoke the destructor of
        // 'MANAGED_TYPE' rather than the destructor of 'TARGET_TYPE'.  This
        // constructor will not compile unless 'MANAGED_TYPE *' is convertible
        // to 'TARGET_TYPE *'.  The behavior is undefined unless the managed
        // object (if any) can be destroyed by the specified 'factory', or if
        // '0 == factory && 0 != ptr', or if the lifetime of the managed object
        // is already managed by another object.  Note that 'bslma::Allocator',
        // and any class publicly and unambiguously derived from
        // 'bslma::Allocator', meets the requirements for 'FACTORY_TYPE'.

    explicit ManagedPtr(bsl::nullptr_t, bsl::nullptr_t = 0);
        // Create an empty managed pointer.  Note that this constructor is
        // necessary to match null-pointer literal arguments, in order to break
        // ambiguities and provide valid type deduction with the other
        // constructor templates in this class.

    template <class FACTORY_TYPE>
    ManagedPtr(bsl::nullptr_t, FACTORY_TYPE *factory);
        // Create an empty managed pointer.  Note that the specified 'factory'
        // is ignored, as an empty managed pointer does not call its deleter.

    ManagedPtr(TARGET_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will invoke the specified 'deleter' with the address of
        // the currently managed object, and with the specified 'cookie' (that
        // the deleter can use for its own purposes), unless '0 == ptr', in
        // which case create an empty managed pointer.  The behavior is
        // undefined if 'ptr' is already managed by another object, or if
        // '0 == deleter && 0 != ptr'.  Note that this constructor is required
        // only because the deprecated overloads cause an ambiguity in its
        // absence; it should be removed when the deprecated overloads are
        // removed.

    template <class MANAGED_TYPE>
    ManagedPtr(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will invoke the specified 'deleter' with the address of
        // the currently managed object, and with the specified 'cookie' (that
        // the deleter can use for its own purposes), unless '0 == ptr', in
        // which case create an empty managed pointer.  This constructor will
        // not compile unless 'MANAGED_TYPE *' is convertible to
        // 'TARGET_TYPE *'.  The deleter will invoke the destructor of
        // 'MANAGED_TYPE' rather than the destructor of 'TARGET_TYPE'.  The
        // behavior is undefined if 'ptr' is already managed by another object,
        // or if '0 == deleter && 0 != ptr'.

#ifndef BDE_OMIT_INTERNAL_DEPRECATED
    template <class MANAGED_TYPE, class MANAGED_BASE>
    ManagedPtr(MANAGED_TYPE *ptr,
               void         *cookie,
               void        (*deleter)(MANAGED_BASE *, void *));
        // [!DEPRECATED!]: Instead, use:
        //..
        //  template <class MANAGED_TYPE>
        //  ManagedPtr(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        //..
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will invoke the specified 'deleter' with the address of
        // the currently managed object, and with the specified 'cookie' (that
        // the deleter can use for its own purposes), unless '0 == ptr', in
        // which case create an empty managed pointer.  This constructor will
        // not compile unless 'MANAGED_TYPE *' is convertible to
        // 'TARGET_TYPE *', and 'MANAGED_TYPE *' is convertible to
        // 'MANAGED_BASE *'.  The deleter will invoke the destructor of
        // 'MANAGED_TYPE' rather than the destructor of 'TARGET_TYPE'.  The
        // behavior is undefined if 'ptr' is already managed by another object,
        // or if '0 == deleter && 0 != ptr'.  Note that this constructor is
        // needed only to avoid ambiguous type deductions when passing a null
        // pointer literal as the 'cookie' when the user passes a deleter
        // taking a type other than 'void *' for its object type.  Also note
        // that this function is *deprecated* as it relies on undefined
        // compiler behavior for its implementation (that luckily performs as
        // required on every platform supported by BDE).

    template <class MANAGED_TYPE,
              class MANAGED_BASE,
              class COOKIE_TYPE,
              class COOKIE_BASE>
    ManagedPtr(MANAGED_TYPE *ptr,
               COOKIE_TYPE  *cookie,
               void        (*deleter)(MANAGED_BASE *, COOKIE_BASE *));
        // [!DEPRECATED!]: Instead, use:
        //..
        //  template <class MANAGED_TYPE>
        //  ManagedPtr(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        //..
        // Create a managed pointer having a target object referenced by the
        // specified 'ptr', owning the managed object '*ptr', and having a
        // deleter that will invoke the specified 'deleter' with the address of
        // the currently managed object, and with the specified 'cookie' (that
        // the deleter can use for its own purposes), unless '0 == ptr', in
        // which case create an empty managed pointer.  This constructor will
        // not compile unless 'MANAGED_TYPE *' is convertible to
        // 'TARGET_TYPE *', and 'MANAGED_TYPE *' is convertible to
        // 'MANAGED_BASE *'.  The deleter will invoke the destructor of
        // 'MANAGED_TYPE' rather than the destructor of 'TARGET_TYPE'.  The
        // behavior is undefined if 'ptr' is already managed by another object,
        // or if '0 == deleter && 0 != ptr'.  Note that this function is
        // *deprecated* as it relies on undefined compiler behavior for its
        // implementation (that luckily performs as required on every platform
        // supported by BDE).
#endif // BDE_OMIT_INTERNAL_DEPRECATED

    ~ManagedPtr();
        // Destroy this managed pointer object.  Destroy the object managed by
        // this managed pointer by invoking the user-supplied deleter, unless
        // this managed pointer is empty, in which case the deleter will *not*
        // be called.

    // MANIPULATORS
    ManagedPtr& operator=(ManagedPtr& rhs)               BSLS_KEYWORD_NOEXCEPT;
    ManagedPtr& operator=(bslmf::MovableRef<ManagedPtr> rhs)
                                                         BSLS_KEYWORD_NOEXCEPT;
        // If this object and the specified 'rhs' manage the same object,
        // return a reference to this managed pointer; otherwise, destroy the
        // managed object owned by this managed pointer, transfer ownership of
        // the managed object owned by 'rhs' to this managed pointer, set this
        // managed pointer to point to the target object referenced by 'rhs',
        // reset 'rhs' to empty, and return a reference to this managed
        // pointer.

#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    template <class BDE_OTHER_TYPE>
    typename bsl::enable_if<
        bsl::is_convertible<BDE_OTHER_TYPE *, TARGET_TYPE *>::value,
        ManagedPtr<TARGET_TYPE> >::type&
    operator=(ManagedPtr<BDE_OTHER_TYPE>&& rhs) BSLS_KEYWORD_NOEXCEPT;
#elif defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    // sun compiler version 12.3 and earlier
    template <class BDE_OTHER_TYPE>
    ManagedPtr<TARGET_TYPE>&
    operator=(bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > rhs)
        BSLS_KEYWORD_NOEXCEPT;
#else // c++03 except old (version <= 12.3) sun compilers
    template <class BDE_OTHER_TYPE>
    typename bsl::enable_if<
        bsl::is_convertible<BDE_OTHER_TYPE *, TARGET_TYPE *>::value,
        ManagedPtr<TARGET_TYPE> >::type&
    operator=(bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > rhs)
        BSLS_KEYWORD_NOEXCEPT;
#endif
        // If this object and the specified 'rhs' manage the same object,
        // return a reference to this managed pointer; otherwise, destroy the
        // managed object owned by this managed pointer, transfer ownership of
        // the managed object owned by 'rhs' to this managed pointer, set this
        // managed pointer to point to the target object referenced by 'rhs',
        // reset 'rhs' to empty, and return a reference to this managed
        // pointer.  'TARGET_TYPE' must be an accessible and unambiguous base
        // of 'BDE_OTHER_TYPE'

    ManagedPtr& operator=(ManagedPtr_Ref<TARGET_TYPE> ref)
                                                         BSLS_KEYWORD_NOEXCEPT;
        // If this object and the managed pointer reference by the specified
        // 'ref' manage the same object, return a reference to this managed
        // pointer; otherwise, destroy the managed object owned by this managed
        // pointer, transfer ownership of the managed object owned by the
        // managed pointer referenced by 'ref', and set this managed pointer to
        // point to the target object currently referenced the managed pointer
        // referenced by 'ref'; then reset the managed pointer referenced by
        // 'ref' to empty, and return a reference to this managed pointer.
        // This operator is (implicitly) used to assign from a managed pointer
        // rvalue, or from a managed pointer to a "compatible" type, where
        // "compatible" means a built-in conversion from 'MANAGED_TYPE *' to
        // 'TARGET_TYPE *' is defined, e.g., 'derived *' to 'base *', 'T *' to
        // 'const T *', or 'T *' to 'void *'.

    ManagedPtr& operator=(bsl::nullptr_t);
        // Destroy the current managed object (if any) and reset this managed
        // pointer to empty.

    template <class REFERENCED_TYPE>
    operator ManagedPtr_Ref<REFERENCED_TYPE>();
        // Return a managed pointer reference, referring to this object.  Note
        // that this conversion operator is used implicitly to allow the
        // construction of managed pointers from rvalues because temporaries
        // cannot be passed by references offering modifiable access.

    void clear();
        // [!DEPRECATED!] Use 'reset' instead.
        //
        // Destroy the current managed object (if any) and reset this managed
        // pointer to empty.

    template <class MANAGED_TYPE>
    void load(MANAGED_TYPE *ptr);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified 'ptr', take ownership of '*ptr' as the currently managed
        // object, and set a deleter that uses the currently installed default
        // allocator to destroy the managed object when invoked (e.g., when
        // this managed pointer object is destroyed), unless '0 == ptr', in
        // which case reset this managed pointer to empty.  The deleter will
        // invoke the destructor of 'MANAGED_TYPE' rather than the destructor
        // of 'TARGET_TYPE'.  This function will not compile unless
        // 'MANAGED_TYPE *' is convertible to 'TARGET_TYPE *'.  The behavior is
        // undefined unless the managed object (if any) can be destroyed by the
        // currently installed default allocator, or if the lifetime of the
        // managed object is already managed by another object.

    template <class MANAGED_TYPE, class FACTORY_TYPE>
    void load(MANAGED_TYPE *ptr, FACTORY_TYPE *factory);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified 'ptr', take ownership of '*ptr' as the currently managed
        // object, and set a deleter that calls 'factory->deleteObject(ptr)' to
        // destroy the managed object when invoked (e.g., when this managed
        // pointer object is destroyed), unless '0 == ptr', in which case reset
        // this managed pointer to empty.  The deleter will invoke the
        // destructor of 'MANAGED_TYPE' rather than the destructor of
        // 'TARGET_TYPE'.  This function will not compile unless
        // 'MANAGED_TYPE *' is convertible to 'TARGET_TYPE *'.  The behavior is
        // undefined unless the managed object (if any) can be destroyed by the
        // specified 'factory',  or if '0 == factory && 0 != ptr', or if the
        // the lifetime of the managed object is already managed by another
        // object.  Note that 'bslma::Allocator', and any class publicly and
        // unambiguously derived from 'bslma::Allocator', meets the
        // requirements for 'FACTORY_TYPE'.

    template <class MANAGED_TYPE>
    void load(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified 'ptr', take ownership of '*ptr' as the currently managed
        // object, and set a deleter that will invoke the specified 'deleter'
        // with the address of the currently managed object, and with the
        // specified 'cookie' (that the deleter can use for its own purposes),
        // unless '0 == ptr', in which case reset this managed pointer to
        // empty.  The behavior is undefined if 'ptr' is already managed by
        // another object, or if '0 == deleter && 0 != ptr'.  Note that GCC 3.4
        // and earlier versions have a bug in template type deduction/overload
        // resolution that causes ambiguities if this signature is available.
        // This function will be restored on that platform once the deprecated
        // signatures are finally removed.

    void load(bsl::nullptr_t = 0, void *cookie = 0, DeleterFunc deleter = 0);
        // Destroy the current managed object (if any) and reset this managed
        // pointer to empty.  Note that the optionally specified 'cookie' and
        // 'deleter' will be ignored, as empty managed pointers do not invoke a
        // deleter.

#ifndef BDE_OMIT_INTERNAL_DEPRECATED
    template <class MANAGED_TYPE, class COOKIE_TYPE>
    void load(MANAGED_TYPE *ptr, COOKIE_TYPE *cookie, DeleterFunc deleter);

    template <class MANAGED_TYPE, class MANAGED_BASE>
    void load(MANAGED_TYPE *ptr,
              void         *cookie,
              void        (*deleter)(MANAGED_BASE *, void *));

    template <class MANAGED_TYPE,
              class MANAGED_BASE,
              class COOKIE_TYPE,
              class COOKIE_BASE>
    void load(MANAGED_TYPE *ptr,
              COOKIE_TYPE  *cookie,
              void        (*deleter)(MANAGED_BASE *, COOKIE_BASE *));
        // [!DEPRECATED!]: Instead, use:
        //..
        //  template <class MANAGED_TYPE>
        //  void load(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        //..
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified 'ptr', take ownership of '*ptr' as the currently managed
        // object, and set a deleter that will invoke the specified 'deleter'
        // with the address of the currently managed object, and with the
        // specified 'cookie' (that the deleter can use for its own purposes),
        // unless '0 == ptr', in which case reset this managed pointer to
        // empty.  The behavior is undefined if 'ptr' is already managed by
        // another object, or if '0 == deleter && 0 != ptr'.  Note that this
        // function is *deprecated* as it relies on undefined compiler behavior
        // for its implementation, but luckily perform as required for all
        // currently supported platforms; on platforms where the non-deprecated
        // overload is not available (e.g., GCC 3.4) code should be written as
        // if it were available, as an appropriate (deprecated) overload will
        // be selected with the correct (non-deprecated) behavior.
#endif // BDE_OMIT_INTERNAL_DEPRECATED

    template <class ALIASED_TYPE>
    void loadAlias(ManagedPtr<ALIASED_TYPE>& alias, TARGET_TYPE *ptr);
        // If the specified 'alias' manages the same object as this managed
        // pointer, set the target object of this managed pointer to be that
        // referenced by the specified 'ptr'; otherwise, destroy the currently
        // managed object (if any), and if 'alias' is empty, reset this managed
        // pointer to empty; otherwise, transfer ownership (and the deleter) of
        // the object managed by 'alias', and set the target object of this
        // managed pointer to be that referenced by 'ptr'.  The behavior is
        // undefined if '0 == ptr' and 'alias' is not empty, or if '0 != ptr'
        // and 'alias' is empty, or if 'ptr' is already managed by a managed
        // pointer other than 'alias'.  Note that this establishes a managed
        // pointer where 'ptr' aliases 'alias'.  The managed object for 'alias'
        // will ultimately be destroyed, and the destructor for 'ptr' is not
        // called directly.

    ManagedPtr_PairProxy<TARGET_TYPE, ManagedPtrDeleter> release();
        // Return a raw pointer to the current target object (if any) and the
        // deleter for the currently managed object, and reset this managed
        // pointer to empty.  It is undefined behavior to run the returned
        // deleter unless the returned pointer to target object is not null.

    TARGET_TYPE *release(ManagedPtrDeleter *deleter);
        // Load the specified 'deleter' for the currently managed object and
        // reset this managed pointer to empty.  Return a raw pointer to the
        // target object (if any) managed by this pointer.  It is undefined
        // behavior to run the returned deleter unless the returned pointer to
        // target object is not null.

    void reset();
        // Destroy the current managed object (if any) and reset this managed
        // pointer to empty.

    void swap(ManagedPtr& other);
        // Exchange the value and ownership of this managed pointer with the
        // specified 'other' managed pointer.

    // ACCESSORS
    operator BoolType() const;
        // Return a value of "unspecified bool" type that evaluates to 'false'
        // if this managed pointer is empty, and 'true' otherwise.  Note that
        // this conversion operator allows a managed pointer to be used within
        // a conditional context, such as within an 'if' or 'while' statement,
        // but does *not* allow managed pointers to be compared (e.g., via '<'
        // or '>').  Also note that a superior solution is available in C++11
        // using the 'explicit operator bool()' syntax, that removes the need
        // for a special boolean-like type and private equality-comparison
        // operators.

    typename bslmf::AddReference<TARGET_TYPE>::Type operator*() const;
        // Return a reference to the target object.  The behavior is undefined
        // if this managed pointer is empty, or if 'TARGET_TYPE' is 'void' or
        // 'const void'.

    TARGET_TYPE *operator->() const;
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.

    const ManagedPtrDeleter& deleter() const;
        // Return a reference to the non-modifiable deleter information
        // associated with this managed pointer.  The behavior is undefined if
        // this managed pointer is empty.

    TARGET_TYPE *get() const;
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.

    TARGET_TYPE *ptr() const;
        // [!DEPRECATED!]: Use 'get' instead.
        //
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.
};

// FREE FUNCTIONS
template <class TARGET_TYPE>
void swap(ManagedPtr<TARGET_TYPE>& a, ManagedPtr<TARGET_TYPE>& b);
    // Efficiently exchange the values of the specified 'a' and 'b' objects.
    // This function provides the no-throw exception-safety guarantee.

                        // =====================
                        // struct ManagedPtrUtil
                        // =====================

struct ManagedPtrUtil {
    // This utility class provides a general no-op deleter, which is useful
    // when creating managed pointers to stack-allocated objects.

    // CLASS METHODS
    static void noOpDeleter(void *, void *);
        // Deleter function that does nothing.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_managedptr.h
#ifndef BSLMA_MANAGEDPTR_VARIADIC_LIMIT
#define BSLMA_MANAGEDPTR_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A
#define BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A BSLMA_MANAGEDPTR_VARIADIC_LIMIT
#endif

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 0

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class ARGS_01>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 1

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 2

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 3

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 4

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 5

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 6

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 7

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 8

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 9

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 10

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 11

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 12

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12,
                                  class ARGS_13>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 13

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12,
                                  class ARGS_13,
                                  class ARGS_14>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) args_14);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 14


#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                              );
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 0

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class ARGS_01>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 1

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 2

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 3

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 4

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 5

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 6

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 7

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 8

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 9

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 10

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 11

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 12

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12,
                                  class ARGS_13>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 13

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class ARGS_01,
                                  class ARGS_02,
                                  class ARGS_03,
                                  class ARGS_04,
                                  class ARGS_05,
                                  class ARGS_06,
                                  class ARGS_07,
                                  class ARGS_08,
                                  class ARGS_09,
                                  class ARGS_10,
                                  class ARGS_11,
                                  class ARGS_12,
                                  class ARGS_13,
                                  class ARGS_14>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) args_14);
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_A >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

    template <class ELEMENT_TYPE, class... ARGS>
    static ManagedPtr<ELEMENT_TYPE> allocateManaged(
                                              bslma::Allocator *basicAllocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template <class ELEMENT_TYPE, class... ARGS>
    static ManagedPtr<ELEMENT_TYPE> makeManaged(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

// }}} END GENERATED CODE
#endif
};

                     // ===========================
                     // struct ManagedPtrNilDeleter
                     // ===========================

template <class TARGET_TYPE>
struct ManagedPtrNilDeleter {
    // [!DEPRECATED!]: Use 'ManagedPtrUtil::noOpDeleter' instead.
    //
    // This utility class provides a general no-op deleter, which is useful
    // when creating managed pointers to stack-allocated objects.  Note that
    // the non-template class 'ManagedPtrUtil' should be used in preference to
    // this deprecated class, avoiding both template bloat and undefined
    // behavior.

    // CLASS METHODS
    static void deleter(void *, void *);
        // Deleter function that does nothing.
};

             // ===========================================
             // private class ManagedPtr_FactoryDeleterType
             // ===========================================

template <class TARGET_TYPE, class FACTORY_TYPE>
struct ManagedPtr_FactoryDeleterType
    : bsl::conditional<
                 bsl::is_convertible<FACTORY_TYPE *, Allocator *>::value,
                 ManagedPtr_FactoryDeleter<TARGET_TYPE, Allocator>,
                 ManagedPtr_FactoryDeleter<TARGET_TYPE, FACTORY_TYPE> > {
    // This metafunction class-template provides a means to compute the
    // preferred deleter function for a factory class for those methods of
    // 'ManagedPtr' that supply only a factory, and no additional deleter
    // function.  The intent is to use a common deleter function for all
    // allocators that implement the 'bslma::Allocator' protocol, rather than
    // create a special deleter function based on the complete type of each
    // allocator, each doing the same thing (invoking the virtual function
    // 'deleteObject').
};

              // ========================================
              // private struct ManagedPtr_DefaultDeleter
              // ========================================

template <class MANAGED_TYPE>
struct ManagedPtr_DefaultDeleter {
    // This 'struct' provides a function-like managed pointer deleter that
    // invokes 'delete' with the passed pointer.

    // CLASS METHODS
    static void deleter(void *ptr, void *);
        // Cast the specified 'ptr' to (template parameter) type
        // 'MANAGED_TYPE *', and then call 'delete' with the cast pointer.
};


// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

                      // ---------------------------------
                      // private struct ManagedPtr_ImpUtil
                      // ---------------------------------

// CLASS METHODS
template <class TYPE>
inline
void *ManagedPtr_ImpUtil::voidify(TYPE *address) BSLS_KEYWORD_NOEXCEPT
{
    return static_cast<void *>(
            const_cast<typename bsl::remove_cv<TYPE>::type *>(address));
}

template <class TYPE>
inline
TYPE *ManagedPtr_ImpUtil::unqualify(const volatile TYPE *address)
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return const_cast<TYPE *>(address);
}

                      // ----------------------------
                      // private class ManagedPtr_Ref
                      // ----------------------------

// CREATORS
template <class TARGET_TYPE>
inline
ManagedPtr_Ref<TARGET_TYPE>::ManagedPtr_Ref(ManagedPtr_Members *base,
                                            TARGET_TYPE        *target)
: d_base_p(base)
, d_cast_p(target)
{
    BSLS_ASSERT_SAFE(0 != base);
}

template <class TARGET_TYPE>
inline
ManagedPtr_Ref<TARGET_TYPE>::~ManagedPtr_Ref()
{
    BSLS_ASSERT_SAFE(0 != d_base_p);
}

// ACCESSORS
template <class TARGET_TYPE>
inline
ManagedPtr_Members *ManagedPtr_Ref<TARGET_TYPE>::base() const
{
    return d_base_p;
}

template <class TARGET_TYPE>
inline
TARGET_TYPE *ManagedPtr_Ref<TARGET_TYPE>::target() const
{
    return d_cast_p;
}

                           // ----------------
                           // class ManagedPtr
                           // ----------------

template <class TARGET_TYPE>
class ManagedPtr<volatile TARGET_TYPE>;
    // This specialization is declared but not defined, in order to provide an
    // early compile-fail check to catch misuse of managed pointer to
    // 'volatile' types, which is explicitly called out as not supported in the
    // primary class template contract.

template <class TARGET_TYPE>
class ManagedPtr<TARGET_TYPE&>;
    // This specialization is declared but not defined, in order to provide an
    // early compile-fail check to catch misuse of managed pointer to reference
    // types, which is explicitly called out as not supported in the primary
    // class template contract.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template <class TARGET_TYPE>
class ManagedPtr<TARGET_TYPE&&>;
    // This specialization is declared but not defined, in order to provide an
    // early compile-fail check to catch misuse of managed pointer to reference
    // types, which is explicitly called out as not supported in the primary
    // class template contract.
#endif

// PRIVATE CLASS METHODS
template <class TARGET_TYPE>
inline
void *ManagedPtr<TARGET_TYPE>::stripBasePointerType(TARGET_TYPE *ptr)
{
    return const_cast<void *>(static_cast<const void *>(ptr));
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
void *
ManagedPtr<TARGET_TYPE>::stripCompletePointerType(MANAGED_TYPE *ptr)
{
    return const_cast<void *>(static_cast<const void *>(ptr));
}

// PRIVATE MANIPULATORS
template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::loadImp(MANAGED_TYPE *ptr,
                                      void         *cookie,
                                      DeleterFunc   deleter)
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    d_members.runDeleter();
    d_members.set(stripCompletePointerType(ptr), cookie, deleter);
    d_members.setAliasPtr(stripBasePointerType(ptr));
}

// CREATORS
template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr()
: d_members()
{
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(MANAGED_TYPE *ptr)
: d_members(stripCompletePointerType(ptr),
            0,
            &ManagedPtr_DefaultDeleter<MANAGED_TYPE>::deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::VALUE));
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(ManagedPtr_Ref<TARGET_TYPE> ref)
                                                          BSLS_KEYWORD_NOEXCEPT
: d_members(*ref.base())
{
    d_members.setAliasPtr(stripBasePointerType(ref.target()));
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(ManagedPtr& original) BSLS_KEYWORD_NOEXCEPT
: d_members(original.d_members)
{
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(bslmf::MovableRef<ManagedPtr> original)
                                                          BSLS_KEYWORD_NOEXCEPT
: d_members(MoveUtil::access(original).d_members)
{
}

#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    ManagedPtr<TARGET_TYPE>::ManagedPtr(
            ManagedPtr<BDE_OTHER_TYPE> &&original,
            typename bsl::enable_if<bsl::is_convertible<BDE_OTHER_TYPE *,
                                                        TARGET_TYPE *>::value,
                                    ManagedPtr_TraitConstraint>::type)
        BSLS_KEYWORD_NOEXCEPT
    : d_members(original.d_members)
#elif defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    // sun compiler version 12.3 and earlier
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    ManagedPtr<TARGET_TYPE>::ManagedPtr(
            bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > original)
        BSLS_KEYWORD_NOEXCEPT
    : d_members(MoveUtil::access(original).d_members)
#else // c++03 except old (version <= 12.3) sun compilers
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    ManagedPtr<TARGET_TYPE>::ManagedPtr(
            bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > original,
            typename bsl::enable_if<bsl::is_convertible<BDE_OTHER_TYPE *,
                                                        TARGET_TYPE *>::value,
                                    ManagedPtr_TraitConstraint>::type)
        BSLS_KEYWORD_NOEXCEPT
    : d_members(MoveUtil::access(original).d_members)
#endif
{
    // This constructor cannot be constrained using a type trait on old Sun
    // compilers (version <= 12.3), so we need the check here.
    #if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
        BSLMF_ASSERT((bsl::is_convertible<BDE_OTHER_TYPE *,
                                          TARGET_TYPE *>::VALUE));
    #endif

    // To deal with the possibility of multiple inheritance, we need to
    // "correct" the target pointer.
    d_members.setAliasPtr(
        stripBasePointerType(
            static_cast<TARGET_TYPE *>(
                static_cast<BDE_OTHER_TYPE *>(
                    d_members.pointer()))));
}


template <class TARGET_TYPE>
template <class ALIASED_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(ManagedPtr<ALIASED_TYPE>&  alias,
                                    TARGET_TYPE               *ptr)
: d_members()
{
    BSLS_ASSERT_SAFE(0 != alias.get() || 0 == ptr);

    if (0 != ptr) {
        d_members.move(&alias.d_members);
        d_members.setAliasPtr(stripBasePointerType(ptr));
    }
}

template <class TARGET_TYPE>
template <class ALIASED_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(
#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
                           ManagedPtr<ALIASED_TYPE>&&                    alias,
#else
                           bslmf::MovableRef<ManagedPtr<ALIASED_TYPE> >  alias,
#endif
                           TARGET_TYPE                                  *ptr)
: d_members()
{
    ManagedPtr<ALIASED_TYPE>& lvalue = alias;

    BSLS_ASSERT_SAFE(0 != lvalue.get() || 0 == ptr);

    if (0 != ptr) {
        d_members.move(&lvalue.d_members);
        d_members.setAliasPtr(stripBasePointerType(ptr));
    }
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE, class FACTORY_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)
: d_members(stripCompletePointerType(ptr),
            factory,
            &ManagedPtr_FactoryDeleterType<MANAGED_TYPE,
                                           FACTORY_TYPE>::type::deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLS_ASSERT_SAFE(0 != factory || 0 == ptr);
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(bsl::nullptr_t, bsl::nullptr_t)
: d_members()
{
}

template <class TARGET_TYPE>
template <class FACTORY_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(bsl::nullptr_t, FACTORY_TYPE *)
: d_members()
{
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(TARGET_TYPE *ptr,
                                    void        *cookie,
                                    DeleterFunc  deleter)
: d_members(stripBasePointerType(ptr), cookie, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(MANAGED_TYPE *ptr,
                                    void         *cookie,
                                    DeleterFunc   deleter)
: d_members(stripCompletePointerType(ptr),
            cookie,
            deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));

    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}

#ifndef BDE_OMIT_INTERNAL_DEPRECATED
template <class TARGET_TYPE>
template <class MANAGED_TYPE, class MANAGED_BASE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(
                                MANAGED_TYPE *ptr,
                                void         *cookie,
                                void        (*deleter)(MANAGED_BASE *, void *))
: d_members(stripCompletePointerType(ptr),
            cookie,
            reinterpret_cast<DeleterFunc>(deleter),
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *,
                                      const MANAGED_BASE *>::value));

    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE,
          class MANAGED_BASE,
          class COOKIE_TYPE,
          class COOKIE_BASE>
inline
ManagedPtr<TARGET_TYPE>::ManagedPtr(
                         MANAGED_TYPE *ptr,
                         COOKIE_TYPE  *cookie,
                         void        (*deleter)(MANAGED_BASE *, COOKIE_BASE *))
: d_members(stripCompletePointerType(ptr),
            static_cast<COOKIE_BASE *>(cookie),
            reinterpret_cast<DeleterFunc>(deleter),
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *,
                                      const MANAGED_BASE *>::value));
    BSLMF_ASSERT((bsl::is_convertible<COOKIE_TYPE *, COOKIE_BASE *>::value));

    // Note that the undefined behavior embodied in the 'reinterpret_cast'
    // above could be removed by inserting an additional forwarding function
    // truly of type 'DeleterFunc' which 'reinterpret_cast's each pointer
    // argument as part of its forwarding behavior.  We choose not to do this
    // on the grounds of simple efficiency, and there is currently no known
    // supported compiler that we use where this does not work as desired.

    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}
#endif // BDE_OMIT_INTERNAL_DEPRECATED

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>::~ManagedPtr()
{
    d_members.runDeleter();
}

// MANIPULATORS
template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>&
ManagedPtr<TARGET_TYPE>::operator=(ManagedPtr& rhs)       BSLS_KEYWORD_NOEXCEPT
{
    d_members.moveAssign(&rhs.d_members);
    return *this;
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>&
ManagedPtr<TARGET_TYPE>::operator=(bslmf::MovableRef<ManagedPtr> rhs)
                                                          BSLS_KEYWORD_NOEXCEPT
{
    ManagedPtr& lvalue = rhs;
    d_members.moveAssign(&lvalue.d_members);
    return *this;
}

#if defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    typename bsl::enable_if<
        bsl::is_convertible<BDE_OTHER_TYPE*, TARGET_TYPE*>::value,
        ManagedPtr<TARGET_TYPE> >::type&
    ManagedPtr<TARGET_TYPE>::operator =(
            ManagedPtr<BDE_OTHER_TYPE>&& rhs) BSLS_KEYWORD_NOEXCEPT
#elif defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    // sun compiler version 12.3 and earlier
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    ManagedPtr<TARGET_TYPE>&
    ManagedPtr<TARGET_TYPE>::operator =(
          bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > rhs)
        BSLS_KEYWORD_NOEXCEPT
#else // c++03 except old (version <= 12.3) sun compilers
    template <class TARGET_TYPE>
    template <class BDE_OTHER_TYPE>
    inline
    typename bsl::enable_if<
        bsl::is_convertible<BDE_OTHER_TYPE *, TARGET_TYPE *>::value,
        ManagedPtr<TARGET_TYPE> >::type&
    ManagedPtr<TARGET_TYPE>::operator =(
          bslmf::MovableRef<ManagedPtr<BDE_OTHER_TYPE> > rhs)
        BSLS_KEYWORD_NOEXCEPT
#endif
{
    // This operator cannot be constrained using a type trait on Sun, so we
    // need the check here.
    #if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
        BSLMF_ASSERT((bsl::is_convertible<BDE_OTHER_TYPE *,
                                          TARGET_TYPE *>::VALUE));
    #endif

    ManagedPtr<BDE_OTHER_TYPE>& lvalue = rhs;
    d_members.moveAssign(&lvalue.d_members);

    // To deal with the possibility of multiple inheritance, we need to
    // "correct" the target pointer.
    d_members.setAliasPtr(
        stripBasePointerType(
            static_cast<TARGET_TYPE *>(
                static_cast<BDE_OTHER_TYPE *>(
                    d_members.pointer()))));

    return *this;
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>&
ManagedPtr<TARGET_TYPE>::operator=(ManagedPtr_Ref<TARGET_TYPE> ref)
                                                          BSLS_KEYWORD_NOEXCEPT
{
    d_members.moveAssign(ref.base());
    d_members.setAliasPtr(stripBasePointerType(ref.target()));
    return *this;
}

template <class TARGET_TYPE>
inline
ManagedPtr<TARGET_TYPE>&
ManagedPtr<TARGET_TYPE>::operator=(bsl::nullptr_t)
{
    this->reset();
    return *this;
}

template <class TARGET_TYPE>
template <class REFERENCED_TYPE>
inline
ManagedPtr<TARGET_TYPE>::operator ManagedPtr_Ref<REFERENCED_TYPE>()
{
    BSLMF_ASSERT((bsl::is_convertible<TARGET_TYPE *,
                                      REFERENCED_TYPE *>::VALUE));

    return ManagedPtr_Ref<REFERENCED_TYPE>(&d_members,
                             static_cast<REFERENCED_TYPE *>(
                             static_cast<TARGET_TYPE *>(d_members.pointer())));
}

template <class TARGET_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::clear()
{
    reset();
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::load(MANAGED_TYPE *ptr)
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));

    typedef ManagedPtr_FactoryDeleter<MANAGED_TYPE, Allocator> DeleterFactory;
    this->loadImp(ptr,
                  static_cast<void *>(Default::allocator()),
                  &DeleterFactory::deleter);
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE, class FACTORY_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::load(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLS_ASSERT_SAFE(0 != factory || 0 == ptr);

    typedef typename
    ManagedPtr_FactoryDeleterType<MANAGED_TYPE, FACTORY_TYPE>::type
                                                                DeleterFactory;

    this->loadImp(ptr, static_cast<void *>(factory), &DeleterFactory::deleter);
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::load(MANAGED_TYPE *ptr,
                                   void         *cookie,
                                   DeleterFunc   deleter)
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    this->loadImp(ptr, cookie, deleter);
}

template <class TARGET_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::load(bsl::nullptr_t, void *, DeleterFunc)
{
    this->reset();
}

#ifndef BDE_OMIT_INTERNAL_DEPRECATED
template <class TARGET_TYPE>
template <class MANAGED_TYPE, class COOKIE_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::load(MANAGED_TYPE *ptr,
                                   COOKIE_TYPE  *cookie,
                                   DeleterFunc   deleter)
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    this->loadImp(ptr, static_cast<void *>(cookie), deleter);
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE, class MANAGED_BASE>
inline
void ManagedPtr<TARGET_TYPE>::load(
                                MANAGED_TYPE *ptr,
                                void         *cookie,
                                void        (*deleter)(MANAGED_BASE *, void *))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::VALUE));
    BSLMF_ASSERT((!bsl::is_void<MANAGED_BASE>::value));
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, MANAGED_BASE *>::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    this->loadImp(ptr, cookie, reinterpret_cast<DeleterFunc>(deleter));
}

template <class TARGET_TYPE>
template <class MANAGED_TYPE,
          class MANAGED_BASE,
          class COOKIE_TYPE,
          class COOKIE_BASE>
inline
void ManagedPtr<TARGET_TYPE>::load(
                         MANAGED_TYPE *ptr,
                         COOKIE_TYPE  *cookie,
                         void        (*deleter)(MANAGED_BASE *, COOKIE_BASE *))
{
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, TARGET_TYPE *>::VALUE));
    BSLMF_ASSERT((bsl::is_convertible<MANAGED_TYPE *, MANAGED_BASE *>::VALUE));
    BSLMF_ASSERT((bsl::is_convertible<COOKIE_TYPE *, COOKIE_BASE *>::VALUE));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    this->loadImp(ptr,
                  static_cast<void *>(static_cast<COOKIE_BASE *>(cookie)),
                  reinterpret_cast<DeleterFunc>(deleter));
}
#endif // BDE_OMIT_INTERNAL_DEPRECATED

template <class TARGET_TYPE>
template <class ALIASED_TYPE>
void ManagedPtr<TARGET_TYPE>::loadAlias(ManagedPtr<ALIASED_TYPE>&  alias,
                                        TARGET_TYPE               *ptr)
{
    BSLS_ASSERT_SAFE(!ptr == !alias.get());  // both null or both non-null

    if (ptr && alias.d_members.pointer()) {
        d_members.moveAssign(&alias.d_members);
        d_members.setAliasPtr(stripBasePointerType(ptr));
    }
    else {
        d_members.runDeleter();
        d_members.clear();
    }
}

template <class TARGET_TYPE>
ManagedPtr_PairProxy<TARGET_TYPE, ManagedPtrDeleter>
ManagedPtr<TARGET_TYPE>::release()
{
    typedef ManagedPtr_PairProxy<TARGET_TYPE, ManagedPtrDeleter> ResultType;

    TARGET_TYPE *p = get();

    // The behavior would be undefined if 'd_members.deleter()' were called
    // when 'p' is null.

    if (p) {
        ResultType result = { p, d_members.deleter() };
        d_members.clear();
        return result;                                                // RETURN
    }
    ResultType result = { p, ManagedPtrDeleter() };
    return result;
}

template <class TARGET_TYPE>
TARGET_TYPE *ManagedPtr<TARGET_TYPE>::release(ManagedPtrDeleter *deleter)
{
    BSLS_ASSERT_SAFE(deleter);

    TARGET_TYPE *result = get();

    // The behavior is undefined if 'd_members.deleter()' is called when
    // 'result' is null.

    if (result) {
        *deleter = d_members.deleter();
        d_members.clear();
    }
    return result;
}

template <class TARGET_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::reset()
{
    d_members.runDeleter();
    d_members.clear();
}

template <class TARGET_TYPE>
inline
void ManagedPtr<TARGET_TYPE>::swap(ManagedPtr& other)
{
    d_members.swap(other.d_members);
}

// ACCESSORS
template <class TARGET_TYPE>
inline
#if defined(BSLS_PLATFORM_CMP_IBM)      // last confirmed with xlC 12.1
ManagedPtr<TARGET_TYPE>::operator typename ManagedPtr::BoolType() const
#else
ManagedPtr<TARGET_TYPE>::operator BoolType() const
#endif
{
    return d_members.pointer()
           ? bsls::UnspecifiedBool<ManagedPtr>::trueValue()
           : bsls::UnspecifiedBool<ManagedPtr>::falseValue();
}

template <class TARGET_TYPE>
inline
typename bslmf::AddReference<TARGET_TYPE>::Type
ManagedPtr<TARGET_TYPE>::operator*() const
{
    BSLS_ASSERT_SAFE(d_members.pointer());

    return *static_cast<TARGET_TYPE *>(d_members.pointer());
}

template <class TARGET_TYPE>
inline
TARGET_TYPE *ManagedPtr<TARGET_TYPE>::operator->() const
{
    return static_cast<TARGET_TYPE *>(d_members.pointer());
}

template <class TARGET_TYPE>
inline
const ManagedPtrDeleter& ManagedPtr<TARGET_TYPE>::deleter() const
{
    BSLS_ASSERT_SAFE(d_members.pointer());

    return d_members.deleter();
}

template <class TARGET_TYPE>
inline
TARGET_TYPE *ManagedPtr<TARGET_TYPE>::get() const
{
    return static_cast<TARGET_TYPE *>(d_members.pointer());
}

template <class TARGET_TYPE>
inline
TARGET_TYPE *ManagedPtr<TARGET_TYPE>::ptr() const
{
    return get();
}

// FREE FUNCTIONS
template <class TARGET_TYPE>
inline
void swap(ManagedPtr<TARGET_TYPE>& a, ManagedPtr<TARGET_TYPE>& b)
{
    a.swap(b);
}

                      // --------------------
                      // class ManagedPtrUtil
                      // --------------------

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_managedptr.h
#ifndef BSLMA_MANAGEDPTR_VARIADIC_LIMIT
#define BSLMA_MANAGEDPTR_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B
#define BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B BSLMA_MANAGEDPTR_VARIADIC_LIMIT
#endif

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 0
template <class ELEMENT_TYPE>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator);
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 0

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 1
template <class ELEMENT_TYPE, class ARGS_01>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 1

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 2
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 2

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 3
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 3

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 4
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 4

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 5
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 5

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 6
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 6

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 7
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 7

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 8
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 8

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 9
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 9

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 10
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 10

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 11
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 11

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 12
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 12

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 13
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12,
                              class ARGS_13>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, args_13));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 13

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 14
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12,
                              class ARGS_13,
                              class ARGS_14>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) args_14)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, args_13),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_14, args_14));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 14


#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 0
template <class ELEMENT_TYPE>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                               )
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                                 );
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 0

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 1
template <class ELEMENT_TYPE, class ARGS_01>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 1

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 2
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 2

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 3
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 3

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 4
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 4

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 5
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 5

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 6
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 6

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 7
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 7

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 8
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 8

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 9
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 9

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 10
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 10

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 11
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 11

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 12
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 12

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 13
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12,
                              class ARGS_13>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, args_13));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 13

#if BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 14
template <class ELEMENT_TYPE, class ARGS_01,
                              class ARGS_02,
                              class ARGS_03,
                              class ARGS_04,
                              class ARGS_05,
                              class ARGS_06,
                              class ARGS_07,
                              class ARGS_08,
                              class ARGS_09,
                              class ARGS_10,
                              class ARGS_11,
                              class ARGS_12,
                              class ARGS_13,
                              class ARGS_14>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) args_11,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) args_12,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) args_13,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) args_14)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, args_11),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, args_12),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, args_13),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_14, args_14));
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}
#endif  // BSLMA_MANAGEDPTR_VARIADIC_LIMIT_B >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class ELEMENT_TYPE, class... ARGS>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::allocateManaged(
                                              bslma::Allocator *basicAllocator,
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    bslma::Allocator *allocator = bslma::Default::allocator(basicAllocator);

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                                    allocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           allocator);
    bslma::ConstructionUtil::construct(
                                 ManagedPtr_ImpUtil::unqualify(objPtr),
                                 allocator,
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, allocator);
}

template <class ELEMENT_TYPE, class... ARGS>
inline
ManagedPtr<ELEMENT_TYPE> ManagedPtrUtil::makeManaged(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    bslma::Allocator *defaultAllocator = bslma::Default::defaultAllocator();

    ELEMENT_TYPE *objPtr = static_cast<ELEMENT_TYPE *>(
                             defaultAllocator->allocate(sizeof(ELEMENT_TYPE)));

    bslma::DeallocatorProctor<bslma::Allocator> proctor(
                                           ManagedPtr_ImpUtil::voidify(objPtr),
                                           defaultAllocator);
    ::new (ManagedPtr_ImpUtil::voidify(objPtr)) ELEMENT_TYPE(
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
    proctor.release();

    return ManagedPtr<ELEMENT_TYPE>(objPtr, defaultAllocator);
}

// }}} END GENERATED CODE
#endif

                      // --------------------------
                      // class ManagedPtrNilDeleter
                      // --------------------------

// CLASS METHODS
template <class TARGET_TYPE>
inline
void ManagedPtrNilDeleter<TARGET_TYPE>::deleter(void *, void *)
{
}

              // ----------------------------------------
              // private struct ManagedPtr_DefaultDeleter
              // ----------------------------------------

// CLASS METHODS
template <class MANAGED_TYPE>
inline
void ManagedPtr_DefaultDeleter<MANAGED_TYPE>::deleter(void *ptr, void *)
{
    delete reinterpret_cast<MANAGED_TYPE *>(ptr);
}

}  // close package namespace

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

namespace bslmf {

template <class TARGET_TYPE>
struct HasPointerSemantics<bslma::ManagedPtr<TARGET_TYPE> > : bsl::true_type
{
};

template <class TARGET_TYPE>
struct IsBitwiseMoveable<bslma::ManagedPtr<TARGET_TYPE> > : bsl::true_type
{
};

}  // close namespace bslmf
}  // close enterprise namespace

namespace bsl {

template <class TARGET_TYPE>
struct is_nothrow_move_constructible<
    BloombergLP::bslma::ManagedPtr<TARGET_TYPE> > : bsl::true_type
{
};

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLMA_MANAGEDPTR_H)
# error Not valid except when included from bslma_managedptr.h
#endif // ! defined(COMPILING_BSLMA_MANAGEDPTR_H)

#endif // ! defined(INCLUDED_BSLMA_MANAGEDPTR_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2022 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
