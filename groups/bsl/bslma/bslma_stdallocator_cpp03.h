// bslma_stdallocator_cpp03.h                                         -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_STDALLOCATOR_CPP03
#define INCLUDED_BSLMA_STDALLOCATOR_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_stdallocator.h
//
//@CLASSES: See bslma_stdallocator.h for list of classes
//
//@SEE_ALSO: bslma_stdallocator
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Sep 22 17:06:46 2022
// Command line: sim_cpp11_features.pl bslma_stdallocator.h

#ifdef COMPILING_BSLMA_STDALLOCATOR_H

namespace bsl {

                              // ===============
                              // class allocator
                              // ===============

template <class TYPE>
class allocator {
    // An STL-compatible allocator that forwards allocation calls to an
    // underlying mechanism object of a type derived from 'bslma::Allocator'.
    // This class template adheres to the allocator requirements defined in
    // section 20.1.5 [lib.allocator.requirements] of the C++ standard and may
    // be used to instantiate any [container] class template that follows the
    // STL allocator protocol.  The allocation mechanism is chosen at run-time,
    // giving the programmer run-time control over how a container allocates
    // and frees memory.

    // DATA
    BloombergLP::bslma::Allocator *d_mechanism;

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(allocator, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(allocator,
                                   BloombergLP::bslmf::IsBitwiseMoveable);
    BSLMF_NESTED_TRAIT_DECLARATION(
        allocator,
        BloombergLP::bslmf::IsBitwiseEqualityComparable);
        // Declare nested type traits for this class.

    // PUBLIC TYPES
    typedef std::size_t     size_type;
    typedef std::ptrdiff_t  difference_type;
    typedef TYPE           *pointer;
    typedef const TYPE     *const_pointer;
    typedef TYPE&           reference;
    typedef const TYPE&     const_reference;
    typedef TYPE            value_type;

    template <class ANY_TYPE>
    struct rebind {
        // This nested 'struct' template, parameterized by 'ANY_TYPE', provides
        // a namespace for an 'other' type alias, which is an allocator type
        // following the same template as this one but that allocates elements
        // of 'ANY_TYPE'.  Note that this allocator type is convertible to and
        // from 'other' for any type, including 'void'.

        typedef allocator<ANY_TYPE> other;
    };

    // CREATORS
    allocator();
        // Create a proxy object which will forward allocation calls to the
        // object pointed to by 'bslma::Default::defaultAllocator()'.
        // Postcondition:
        //..
        //  this->mechanism() == bslma::Default::defaultAllocator();
        //..

    allocator(BloombergLP::bslma::Allocator *mechanism);            // IMPLICIT
        // Convert a 'bslma::Allocator' pointer to an 'allocator' object which
        // forwards allocation calls to the object pointed to by the specified
        // 'mechanism'.  If 'mechanism' is 0, then the currently installed
        // default allocator is used instead.  Postcondition:
        // '0 == mechanism || this->mechanism() == mechanism'.

    allocator(const allocator& original);
        // Create a proxy object using the same mechanism as the specified
        // 'original'.  Postcondition: 'this->mechanism() == rhs.mechanism()'.

    template <class ANY_TYPE>
    allocator(const allocator<ANY_TYPE>& rhs);
        // Create a proxy object sharing the same mechanism object as the
        // specified 'rhs'.  The newly constructed allocator will compare equal
        // to 'rhs', even though they are instantiated on different types.
        // Postcondition: 'this->mechanism() == rhs.mechanism()'.

    //! ~allocator();
        // Destroy this object.  Note that this does not delete the object
        // pointed to by 'mechanism()'.  Also note that this method's
        // definition is compiler generated.

    // MANIPULATORS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_DEFAULTED_FUNCTIONS
    allocator& operator=(const allocator& rhs) = default;
        // Assign to this object the value of the specified 'rhs'.
        // Postcondition: 'this->mechanism() == rhs->mechanism()'.  Note that
        // this does not delete the object pointed to by the previous value of
        // 'mechanism()'.  Also note that this method's definition is compiler
        // generated.  Also note that this must be explicitly defaulted to
        // silence compiler warnings on later versions of C++.
#else
    //! allocator& operator=(const allocator& rhs) = default;
#endif

    pointer allocate(size_type n, const void *hint = 0);
        // Allocate enough (properly aligned) space for the specified 'n'
        // objects of (template parameter) 'TYPE' by calling 'allocate' on the
        // mechanism object.  The optionally specified 'hint' argument is
        // ignored by this allocator type.  The behavior is undefined unless
        // 'n <= max_size()'.

    void deallocate(pointer p, size_type n = 1);
        // Return memory previously allocated with 'allocate' to the underlying
        // mechanism object by calling 'deallocate' on the mechanism object
        // with the specified 'p'.  The optionally specified 'n' argument is
        // ignored by this allocator type.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_stdallocator.h
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#endif
#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    void construct(ELEMENT_TYPE *address);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 0

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class Args_01>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 1

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 2

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 3

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 4

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 5

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 6

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 7

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 8

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 9

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 10

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 11

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 12

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 13

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    void construct(ELEMENT_TYPE *address,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14);
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_A >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class ELEMENT_TYPE, class... Args>
    void construct(ELEMENT_TYPE *address,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments);
// }}} END GENERATED CODE
#endif

template <class ELEMENT_TYPE>
void destroy(ELEMENT_TYPE *address);
        // Call the 'TYPE' destructor for the object pointed to by the
        // specified 'p'.  Do not directly deallocate any memory.

    // ACCESSORS
pointer address(reference x) const;
        // Return the address of the object referred to by the specified 'x',
        // even if the (template parameter) 'TYPE' overloads the unary
        // 'operator&'.

const_pointer address(const_reference x) const;
        // Return the address of the object referred to by the specified 'x',
        // even if the (template parameter) 'TYPE' overloads the unary
        // 'operator&'.

size_type max_size() const;
        // Return the maximum number of elements of (template parameter) 'TYPE'
        // that can be allocated using this allocator.  Note that there is no
        // guarantee that attempts at allocating fewer elements than the value
        // returned by 'max_size' will not throw.

BloombergLP::bslma::Allocator *mechanism() const;
        // Return a pointer to the mechanism object to which this proxy
        // forwards allocation and deallocation calls.

allocator<TYPE> select_on_container_copy_construction() const;
        // TBD: add comment
}
;

                           // =====================
                           // class allocator<void>
                           // =====================

template <>
class allocator<void> {
    // Specialization of 'allocator<T>' where 'T' is 'void'.  Does not contain
    // members that are unrepresentable for 'void'

    // DATA
    BloombergLP::bslma::Allocator *d_mechanism;

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(allocator, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(allocator,
                                   BloombergLP::bslmf::IsBitwiseMoveable);
    BSLMF_NESTED_TRAIT_DECLARATION(
        allocator,
        BloombergLP::bslmf::IsBitwiseEqualityComparable);
        // Declare nested type traits for this class.

    // PUBLIC TYPES
    typedef std::size_t     size_type;
    typedef std::ptrdiff_t  difference_type;
    typedef void           *pointer;
    typedef const void     *const_pointer;
    typedef void            value_type;

    template <class ANY_TYPE>
    struct rebind {
        typedef allocator<ANY_TYPE> other;
    };

    // CREATORS
    allocator();
        // Construct a proxy object which will forward allocation calls to the
        // object pointed to by 'bslma::Default::defaultAllocator()'.

    allocator(BloombergLP::bslma::Allocator *mechanism);            // IMPLICIT
        // Convert a 'bslma::Allocator' pointer to an 'allocator' object which
        // forwards allocation calls to the object pointed to by the specified
        // 'mechanism'.  If 'mechanism' is 0, then the current default
        // allocator is used instead.  Postcondition:
        // '0 == mechanism || this->mechanism() == mechanism'.

    allocator(const allocator& original);
        // Create a proxy object using the same mechanism as the specified
        // 'original'.  Postcondition: 'this->mechanism() == rhs.mechanism()'.

    template <class ANY_TYPE>
    allocator(const allocator<ANY_TYPE>& rhs);
        // Construct a proxy object sharing the same mechanism object as the
        // specified 'rhs'.  The newly constructed allocator will compare equal
        // to 'rhs', even though they are instantiated on different types.
        // Postcondition: 'this->mechanism() == rhs.mechanism()'.

    //! ~allocator();
        // Destroy this object.  Note that this does not delete the object
        // pointed to by 'mechanism()'.  Also note that this method's
        // definition is compiler generated.

    // MANIPULATORS
    //! allocator& operator=(const allocator& rhs);
        // Assign this object the value of the specified 'rhs'.  Postcondition:
        // 'this->mechanism() == rhs->mechanism()'.  Note that this does not
        // delete the object pointed to by the previous value of 'mechanism()'.
        // Also note that this method's definition is compiler generated.

    // ACCESSORS
    BloombergLP::bslma::Allocator *mechanism() const;
        // Return a pointer to the mechanism object to which this proxy
        // forwards allocation and deallocation calls.

    allocator<void> select_on_container_copy_construction() const;
        // TBD: add comment
};

                  // ========================================
                  // class allocator_traits<allocator<TYPE> >
                  // ========================================

template <class TYPE>
struct allocator_traits<allocator<TYPE> > {
    // This 'struct' template provides a specialization of the
    // 'allocator_traits' class template for 'bsl::allocator'.

    // PUBLIC TYPES
    typedef allocator<TYPE> allocator_type;
    typedef TYPE            value_type;

    typedef TYPE           *pointer;
    typedef const TYPE     *const_pointer;
    typedef void           *void_pointer;
    typedef const void     *const_void_pointer;
    typedef std::ptrdiff_t  difference_type;
    typedef std::size_t     size_type;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES
    template <class ELEMENT_TYPE>
    using rebind_alloc = allocator<ELEMENT_TYPE>;

    template <class ELEMENT_TYPE>
    using rebind_traits = allocator_traits<allocator<ELEMENT_TYPE> >;
#else
    template <class ELEMENT_TYPE>
    struct rebind_alloc : allocator<ELEMENT_TYPE> {
        rebind_alloc()
        : allocator<ELEMENT_TYPE>()
        {
        }

        template <typename ARG>
        rebind_alloc(const ARG& allocatorArg)
            // Convert from anything that can be used to cosntruct the base
            // type.  This might be better if SFINAE-ed out using
            // 'is_convertible', but stressing older compilers more seems
            // unwise.
        : allocator<ELEMENT_TYPE>(allocatorArg)
        {
        }
    };

    template <class ELEMENT_TYPE>
    struct rebind_traits : allocator_traits<allocator<ELEMENT_TYPE> > {
    };
#endif

    static pointer allocate(allocator<TYPE>& m, size_type n)
    {
        return m.allocate(n);
    }

    static pointer allocate(allocator<TYPE>&   m,
                            size_type          n,
                            const_void_pointer hint)
    {
        return m.allocate(n, hint);
    }

    static void deallocate(allocator<TYPE>& m, pointer p, size_type n)
    {
        m.deallocate(p, n);
    }

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_stdallocator.h
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#endif
#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 0
    template <class ELEMENT_TYPE>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p)
    {
        m.construct(p);
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 0

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 1
    template <class ELEMENT_TYPE, class Args_01>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 1

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 2

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 3

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 4

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 5

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 6

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 7

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 8

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 9

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 10

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 11

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 12

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 13

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
                       BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
    }
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_B >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class ELEMENT_TYPE, class... Args>
    static void construct(allocator<TYPE>&  m,
                          ELEMENT_TYPE     *p,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
    {
        m.construct(p, BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
    }
// }}} END GENERATED CODE
#endif

    template <class ELEMENT_TYPE>
    static void destroy(allocator<TYPE>& m, ELEMENT_TYPE *p)
    {
        m.destroy(p);
    }

    static size_type max_size(const allocator<TYPE>& m)
    {
        return m.max_size();
    }

    // Allocator propagation traits
    static allocator<TYPE> select_on_container_copy_construction(
                                                        const allocator<TYPE>&)
    {
        return allocator<TYPE>();
    }

    typedef false_type is_always_equal;

    typedef false_type propagate_on_container_copy_assignment;

    typedef false_type propagate_on_container_move_assignment;

    typedef false_type propagate_on_container_swap;
};

// FREE OPERATORS
template <class T1, class T2>
inline
bool operator==(const allocator<T1>& lhs, const allocator<T2>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' are proxies for the same
    // 'bslma::Allocator' object.  This is a practical implementation of the
    // STL requirement that two allocators compare equal if and only if memory
    // allocated from one can be deallocated from the other.  Note that the two
    // allocators need not be instantiated on the same type in order to compare
    // equal.

template <class T1, class T2>
inline
bool operator!=(const allocator<T1>& lhs, const allocator<T2>& rhs);
    // Return 'true' unless the specified 'lhs' and 'rhs' are proxies for the
    // same 'bslma::Allocator' object, in which case return 'false'.  This is a
    // practical implementation of the STL requirement that two allocators
    // compare equal if and only if memory allocated from one can be
    // deallocated from the other.  Note that the two allocators need not be
    // instantiated on the same type in order to compare equal.

template <class TYPE>
inline
bool operator==(const allocator<TYPE>&         lhs,
                BloombergLP::bslma::Allocator *rhs);
    // Return 'true' if the specified 'lhs' is a proxy for the specified 'rhs',
    // and 'false' otherwise.  Note that 'rhs' points to a *modifiable*
    // 'bslma::Allocator', as 'bsl::allocator' cannot proxy a 'const
    // bslma::Allocator *'

template <class TYPE>
inline
bool operator!=(const allocator<TYPE>&         lhs,
                BloombergLP::bslma::Allocator *rhs);
    // Return 'true' unless the specified 'lhs' is a proxy for the specified
    // 'rhs', in which case return 'false'.  Note that 'rhs' points to a
    // *modifiable* 'bslma::Allocator', as 'bsl::allocator' cannot proxy a
    // 'const bslma::Allocator *'
template <class TYPE>
inline
bool operator==(BloombergLP::bslma::Allocator *lhs,
                const allocator<TYPE>&         rhs);
    // Return 'true' if the specified 'rhs' is a proxy for the specified 'lhs',
    // and 'false' otherwise.  Note that 'lhs' points to a *modifiable*
    // 'bslma::Allocator', as 'bsl::allocator' cannot proxy a 'const
    // bslma::Allocator *'

template <class TYPE>
inline
bool operator!=(BloombergLP::bslma::Allocator *lhs,
                const allocator<TYPE>&         rhs);
    // Return 'true' unless the specified 'rhs' is a proxy for the specified
    // 'lhs', in which case return 'false'.  Note that 'lhs' points to a
    // *modifiable* 'bslma::Allocator', as 'bsl::allocator' cannot proxy a
    // 'const bslma::Allocator *'

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                              // ---------------
                              // class allocator
                              // ---------------

// LOW-LEVEL ACCESSORS
template <class TYPE>
inline
BloombergLP::bslma::Allocator *allocator<TYPE>::mechanism() const
{
    return d_mechanism;
}

// CREATORS
template <class TYPE>
inline
allocator<TYPE>::allocator()
: d_mechanism(BloombergLP::bslma::Default::defaultAllocator())
{
}

template <class TYPE>
inline
allocator<TYPE>::allocator(BloombergLP::bslma::Allocator *mechanism)
: d_mechanism(BloombergLP::bslma::Default::allocator(mechanism))
{
}

template <class TYPE>
inline
allocator<TYPE>::allocator(const allocator& original)
: d_mechanism(original.mechanism())
{
}

template <class TYPE>
template <class ANY_TYPE>
inline
allocator<TYPE>::allocator(const allocator<ANY_TYPE>& rhs)
: d_mechanism(rhs.mechanism())
{
}

// MANIPULATORS
template <class TYPE>
inline
typename allocator<TYPE>::pointer allocator<TYPE>::allocate(
                                           typename allocator::size_type  n,
                                           const void                    *hint)
{
    BSLS_ASSERT_SAFE(n <= this->max_size());

    (void) hint;  // suppress unused parameter warning
    return static_cast<pointer>(d_mechanism->allocate(n * sizeof(TYPE)));
}

template <class TYPE>
inline
void allocator<TYPE>::deallocate(typename allocator::pointer   p,
                                 typename allocator::size_type n)
{
    (void) n;  // suppress unused parameter warning
    d_mechanism->deallocate(p);
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_stdallocator.h
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C
#define BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C BSLMA_STDALLOCATOR_VARIADIC_LIMIT
#endif
#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 0
template <class TYPE>
template <class ELEMENT_TYPE>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism);
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 0

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 1
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 1

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 2
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 2

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 3
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 3

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 4
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 4

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 5
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 5

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 6
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 6

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 7
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 7

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 8
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 8

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 9
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 9

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 10
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 10

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 11
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 11

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 12
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 12

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 13
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                         BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 13

#if BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 14
template <class TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13,
                              class Args_14>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                         BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                         BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
                         BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
}
#endif  // BSLMA_STDALLOCATOR_VARIADIC_LIMIT_C >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class TYPE>
template <class ELEMENT_TYPE, class... Args>
inline
void allocator<TYPE>::construct(ELEMENT_TYPE *address,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                            address,
                            d_mechanism,
                            BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
}
// }}} END GENERATED CODE
#endif

template <class TYPE>
template <class ELEMENT_TYPE>
inline
void allocator<TYPE>::destroy(ELEMENT_TYPE *address)
{
    BloombergLP::bslma::DestructionUtil::destroy(address);
}

// ACCESSORS
template <class TYPE>
inline
typename allocator<TYPE>::const_pointer allocator<TYPE>::address(
                                                       const_reference x) const
{
    return BSLS_UTIL_ADDRESSOF(x);
}

template <class TYPE>
inline
typename allocator<TYPE>::pointer allocator<TYPE>::address(reference x) const
{
    return BSLS_UTIL_ADDRESSOF(x);
}

template <class TYPE>
inline
typename allocator<TYPE>::size_type allocator<TYPE>::max_size() const
{
    // Return the largest value, 'v', such that 'v * sizeof(T)' fits in a
    // 'size_type'.

    // We will calculate MAX_NUM_BYTES based on our knowledge that
    // 'bslma::Allocator::size_type' is just an alias for 'std::size_t'.  First
    // demonstrate that is true:

    BSLMF_ASSERT((bsl::is_same<BloombergLP::bslma::Allocator::size_type,
                               std::size_t>::value));

    static const std::size_t MAX_NUM_BYTES    = ~std::size_t(0);
    static const std::size_t MAX_NUM_ELEMENTS = MAX_NUM_BYTES / sizeof(TYPE);

    return MAX_NUM_ELEMENTS;
}

template <class TYPE>
inline
allocator<TYPE> allocator<TYPE>::select_on_container_copy_construction() const
{
    return allocator<TYPE>();
}

                           // ---------------------
                           // class allocator<void>
                           // ---------------------

// LOW-LEVEL ACCESSORS
inline
BloombergLP::bslma::Allocator *allocator<void>::mechanism() const
{
    return d_mechanism;
}

// CREATORS
inline
allocator<void>::allocator()
: d_mechanism(BloombergLP::bslma::Default::defaultAllocator())
{
}

inline
allocator<void>::allocator(BloombergLP::bslma::Allocator *mechanism)
: d_mechanism(BloombergLP::bslma::Default::allocator(mechanism))
{
}

// 'template <>' is needed only for versions of xlC prior to 9
#if defined(__xlC__) && __xlC__ < 0x900
template <>
#endif
inline
allocator<void>::allocator(const allocator<void>& original)
: d_mechanism(original.mechanism())
{
}

template <class ANY_TYPE>
inline
allocator<void>::allocator(const allocator<ANY_TYPE>& rhs)
: d_mechanism(rhs.mechanism())
{
}

inline
allocator<void> allocator<void>::select_on_container_copy_construction() const
{
    return allocator<void>();
}

// FREE OPERATORS
template <class T1, class T2>
inline
bool operator==(const allocator<T1>& lhs, const allocator<T2>& rhs)
{
    return lhs.mechanism() == rhs.mechanism();
}

template <class T1, class T2>
inline
bool operator!=(const allocator<T1>& lhs, const allocator<T2>& rhs)
{
    return !(lhs == rhs);
}

template <class TYPE>
inline
bool operator==(const allocator<TYPE>&         lhs,
                BloombergLP::bslma::Allocator *rhs)
{
    return lhs.mechanism() == rhs;
}

template <class TYPE>
inline
bool operator!=(const allocator<TYPE>&         lhs,
                BloombergLP::bslma::Allocator *rhs)
{
    return !(lhs == rhs);
}

template <class TYPE>
inline
bool operator==(BloombergLP::bslma::Allocator *lhs,
                const allocator<TYPE>&         rhs)
{
    return lhs == rhs.mechanism();
}

template <class TYPE>
inline
bool operator!=(BloombergLP::bslma::Allocator *lhs,
                const allocator<TYPE>&         rhs)
{
    return !(lhs == rhs);
}

}  // close namespace bsl

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

namespace BloombergLP {
namespace bslma {

template <class TYPE>
struct UsesBslmaAllocator< ::bsl::allocator<TYPE> > : bsl::false_type {
};

}  // close namespace bslma
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMA_STDALLOCATOR_H)
# error Not valid except when included from bslma_stdallocator.h
#endif // ! defined(COMPILING_BSLMA_STDALLOCATOR_H)

#endif // ! defined(INCLUDED_BSLMA_STDALLOCATOR_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2022 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
