// bslmf_invokeresult_cpp03.h                                         -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMF_INVOKERESULT_CPP03
#define INCLUDED_BSLMF_INVOKERESULT_CPP03

//@PURPOSE: Provide C++03 implementation for bslmf_invokeresult.h
//
//@CLASSES: See bslmf_invokeresult.h for list of classes
//
//@SEE_ALSO: bslmf_invokeresult
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Fri Feb 17 15:55:33 2023
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h

#ifdef COMPILING_BSLMF_INVOKERESULT_H

#if   defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE) \
 && !(defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION == 1800)
// The implementation of C++17 semantics in this component depends upon the
// use of 'decltype' for expression SFINAE.  MSVC 2013 (which has version
// number 1800) claims to support 'decltype', but does not have a sufficiently
// functional implementation of expression sfinae to enable C++17 semantics.
#define BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS 1
#endif

namespace BloombergLP {
namespace bslmf {

                 // ==========================================
                 // class template InvokeResultDeductionFailed
                 // ==========================================

struct InvokeResultDeductionFailed {
    // When 'invoke_result' cannot deduce the actual return type of a functor
    // (in C++03 mode), it yields this type as a placeholder.  The advantage of
    // using this placeholder instead of a compilation failure (e.g., using a
    // static assert) is that the return type of an INVOKE() operation is
    // often discarded, so our failure to deduce the return type is often
    // harmless.  Since 'InvokeResultDeductionFailed' is a return type, it must
    // be convertible from the actual return type; this conversion is
    // accomplished by means of a constructor that makes it convertible from
    // *any* type.

    // CREATORS
    template <class t_TYPE>
    InvokeResultDeductionFailed(const t_TYPE&)
    {
    }
        // Convert from an arbitrary type.  The actual argument value is
        // discarded.
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_A
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_A BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_BaseCalcUtil;

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_BaseCalcUtil;

// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

                        // ============================
                        // class template invoke_result
                        // ============================

namespace bsl {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_B
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_B BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
class invoke_result;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
template <class t_FN>
class invoke_result<t_FN>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
template <class t_FN, class t_ARGTYPES_01>
class invoke_result<t_FN, t_ARGTYPES_01>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08,
                          t_ARGTYPES_09>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08,
                                                             t_ARGTYPES_09>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08,
                          t_ARGTYPES_09,
                          t_ARGTYPES_10>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08,
                                                             t_ARGTYPES_09,
                                                             t_ARGTYPES_10>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08,
                          t_ARGTYPES_09,
                          t_ARGTYPES_10,
                          t_ARGTYPES_11>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08,
                                                             t_ARGTYPES_09,
                                                             t_ARGTYPES_10,
                                                             t_ARGTYPES_11>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08,
                          t_ARGTYPES_09,
                          t_ARGTYPES_10,
                          t_ARGTYPES_11,
                          t_ARGTYPES_12>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08,
                                                             t_ARGTYPES_09,
                                                             t_ARGTYPES_10,
                                                             t_ARGTYPES_11,
                                                             t_ARGTYPES_12>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
class invoke_result<t_FN, t_ARGTYPES_01,
                          t_ARGTYPES_02,
                          t_ARGTYPES_03,
                          t_ARGTYPES_04,
                          t_ARGTYPES_05,
                          t_ARGTYPES_06,
                          t_ARGTYPES_07,
                          t_ARGTYPES_08,
                          t_ARGTYPES_09,
                          t_ARGTYPES_10,
                          t_ARGTYPES_11,
                          t_ARGTYPES_12,
                          t_ARGTYPES_13>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                                             t_ARGTYPES_02,
                                                             t_ARGTYPES_03,
                                                             t_ARGTYPES_04,
                                                             t_ARGTYPES_05,
                                                             t_ARGTYPES_06,
                                                             t_ARGTYPES_07,
                                                             t_ARGTYPES_08,
                                                             t_ARGTYPES_09,
                                                             t_ARGTYPES_10,
                                                             t_ARGTYPES_11,
                                                             t_ARGTYPES_12,
                                                             t_ARGTYPES_13>::
      BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_FN, class... t_ARGTYPES>
class invoke_result
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES...>::
      BaseType {

};

// }}} END GENERATED CODE
#endif

}  // close namespace bsl

// ============================================================================
//                              TEMPLATE IMPLEMENTATIONS
// ============================================================================

namespace BloombergLP {
namespace bslmf {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_C
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_C BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <bool t_IS_FUNCPTR,
          bool t_IS_MEMFUNCPTR,
          bool t_IS_MEMOBJPTR,
          class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_Imp;



#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0
template <class t_FN>
struct InvokeResult_BaseCalcUtil<t_FN> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08,
                                                          t_ARGTYPES_09>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08,
                                                          t_ARGTYPES_09,
                                                          t_ARGTYPES_10>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08,
                                                          t_ARGTYPES_09,
                                                          t_ARGTYPES_10,
                                                          t_ARGTYPES_11>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08,
                                                          t_ARGTYPES_09,
                                                          t_ARGTYPES_10,
                                                          t_ARGTYPES_11,
                                                          t_ARGTYPES_12>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_BaseCalcUtil<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12,
                                       t_ARGTYPES_13> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES_01,
                                                          t_ARGTYPES_02,
                                                          t_ARGTYPES_03,
                                                          t_ARGTYPES_04,
                                                          t_ARGTYPES_05,
                                                          t_ARGTYPES_06,
                                                          t_ARGTYPES_07,
                                                          t_ARGTYPES_08,
                                                          t_ARGTYPES_09,
                                                          t_ARGTYPES_10,
                                                          t_ARGTYPES_11,
                                                          t_ARGTYPES_12,
                                                          t_ARGTYPES_13>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <bool     t_IS_FUNCPTR,
          bool     t_IS_MEMFUNCPTR,
          bool     t_IS_MEMOBJPTR,
          class    t_FN,
          class... t_ARGTYPES>
struct InvokeResult_Imp;


template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_BaseCalcUtil {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<t_FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR ||
                                          k_IS_MEMOBJPTR,
                                      F,
                                      t_FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          t_ARGTYPES...>
        BaseType;
};

// }}} END GENERATED CODE
#endif

                      // ===============================
                      // struct InvokeResult_VoidChecker
                      // ===============================

struct InvokeResult_VoidChecker : Tag<true> {
    // Empty type used to detect void expressions.  The size of this type is
    // the same as 'bslmf::Tag<1>'.
};

template <class t_TYPE>
typename bsl::enable_if<!bsl::is_void<t_TYPE>::value, Tag<false> >::type
operator,(const t_TYPE&, InvokeResult_VoidChecker);
    // Return 'InvokeResult_VoidChecker()' if the left argument is of type
    // cv-'void'; otherwise 'bslmf::Tag<false>()'.  This overload of the comma
    // operator is declared but not defined, and is intended to be used in
    // metafunctions in an unevaluated context to detect void expressions.  For
    // any non-void expression 'expr', '(expr,InvokeResult_VoidChecker())',
    // will match this overload and produce a result of type
    // 'bslmf::Tag<false>'.  However, 'const t_TYPE&' will not match 'void', so
    // if 'expr' is a void expression, the built-in comma operator is matched
    // and the result will have type 'InvokeResult_VoidChecker' (i.e., the
    // second argument).
    //
    // Note that Sun CC incorrectly matches this overload for a void
    // expression, then fails hard.  The 'enable_if' prevents this match for
    // Sun CC and any other compilers that may similarly match 'void' and is
    // harmless for compilers that don't.

struct InvokeResult_Index {
    // Metafunction helpers for deducing the return type of an expression.

    enum {
        // Enumeration of possible return types.

        e_VOID,
        e_BOOL,
        e_CHAR,
        e_SCHAR,
        e_UCHAR,
        e_CHAR8_T,
        e_WCHAR_T,
        e_CHAR16_T,
        e_CHAR32_T,
        e_SHORT,
        e_USHORT,
        e_INT,
        e_UNSIGNED,
        e_LONG,
        e_ULONG,
        e_LONG_LONG,
        e_ULONG_LONG,
        e_FLOAT,
        e_DOUBLE,
        e_LONG_DOUBLE,

        // Pointer to void is special among pointers because it cannot be
        // dereferenced.
        e_VOIDPTR,
        e_CONST_VOIDPTR,
        e_VOLATILE_VOIDPTR,
        e_CONST_VOLATILE_VOIDPTR,

        e_NULLPTR_T,
        e_POINTER, // Any pointer type other than 'void *' or 'nullptr_t'
        e_OTHER    // Anything other than above
    };

    // CLASS METHODS
    static bslmf::Tag<e_BOOL>                   fromVal(bool&                );
    static bslmf::Tag<e_CHAR>                   fromVal(char&                );
    static bslmf::Tag<e_SCHAR>                  fromVal(signed char&         );
    static bslmf::Tag<e_UCHAR>                  fromVal(unsigned char&       );
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UTF8_CHAR_TYPE
    static bslmf::Tag<e_CHAR8_T>                fromVal(char8_t&             );
#endif
    static bslmf::Tag<e_WCHAR_T>                fromVal(wchar_t&             );
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES
    static bslmf::Tag<e_CHAR16_T>               fromVal(char16_t&            );
    static bslmf::Tag<e_CHAR32_T>               fromVal(char32_t&            );
#endif
    static bslmf::Tag<e_SHORT>                  fromVal(short&               );
    static bslmf::Tag<e_USHORT>                 fromVal(unsigned short&      );
    static bslmf::Tag<e_INT>                    fromVal(int&                 );
    static bslmf::Tag<e_UNSIGNED>               fromVal(unsigned&            );
    static bslmf::Tag<e_LONG>                   fromVal(long&                );
    static bslmf::Tag<e_ULONG>                  fromVal(unsigned long&       );
    static bslmf::Tag<e_LONG_LONG>              fromVal(long long&           );
    static bslmf::Tag<e_ULONG_LONG>             fromVal(unsigned long long&  );
    static bslmf::Tag<e_FLOAT>                  fromVal(float&               );
    static bslmf::Tag<e_DOUBLE>                 fromVal(double&              );
    static bslmf::Tag<e_LONG_DOUBLE>            fromVal(long double&         );
    static bslmf::Tag<e_VOIDPTR>                fromVal(void *&              );
    static bslmf::Tag<e_CONST_VOIDPTR>          fromVal(const void *&        );
    static bslmf::Tag<e_VOLATILE_VOIDPTR>       fromVal(volatile void *&     );
    static bslmf::Tag<e_CONST_VOLATILE_VOIDPTR> fromVal(const volatile void*&);
    static bslmf::Tag<e_NULLPTR_T>              fromVal(bsl::nullptr_t&);
    template <class t_TP>
    static bslmf::Tag<e_POINTER>                fromVal(t_TP *&);
    template <class t_TP>
    static bslmf::Tag<e_OTHER>                  fromVal(t_TP&);
        // Return a tag type representing the argument type.  These functions
        // are declared but not defined and are intended to be used in an
        // unevaluated context (e.g., within 'sizeof') to convert an expression
        // into a compile-time enumeration constant.
};

template <int t_INDEX> struct InvokeResult_Type;
    // Metafunction to convert a type index back to a type.  For each
    // specialization of this struct, the 'type' member will be the type
    // corresponding to 'index'.  For example, if 'index' is 'e_UCHAR', then
    // 'InvokeResult_Type<index>::type' is 'unsigned char'.

// Turn off bde_verify warnings for "Declaration without tag".  Pedantically,
// every 'type' declared in a metafunction should have the tag '// TYPES', but
// that breaks up the clean 3-line declaration of each specialization, making
// the pattern harder to for the eye to follow.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -KS00
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOID>
    { typedef void               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_BOOL>
    { typedef bool               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR>
    { typedef char               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_SCHAR>
    { typedef signed char        type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_UCHAR>
    { typedef unsigned char      type; };
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UTF8_CHAR_TYPE
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR8_T>
    { typedef char8_t            type; };
#endif
template <>
struct InvokeResult_Type<InvokeResult_Index::e_WCHAR_T>
    { typedef wchar_t            type; };
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR16_T>
    { typedef char16_t           type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR32_T>
    { typedef char32_t           type; };
#endif
template <>
struct InvokeResult_Type<InvokeResult_Index::e_SHORT>
    { typedef short              type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_USHORT>
    { typedef unsigned short     type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_INT>
    { typedef int                type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_UNSIGNED>
    { typedef unsigned           type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG>
    { typedef long               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_ULONG>
    { typedef unsigned long      type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG_LONG>
    { typedef long long          type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_ULONG_LONG>
    { typedef unsigned long long type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_FLOAT>
    { typedef float              type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_DOUBLE>
    { typedef double             type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG_DOUBLE>
    { typedef long double        type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOIDPTR>
    { typedef void              *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CONST_VOIDPTR>
    { typedef const void        *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOLATILE_VOIDPTR>
    { typedef volatile void     *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CONST_VOLATILE_VOIDPTR>
    { typedef const volatile void *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_NULLPTR_T>
    { typedef bsl::nullptr_t     type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_POINTER>
    { typedef void              *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_OTHER>
    { typedef InvokeResultDeductionFailed type; };
// Re-enable warnings for "Declaration without tag"
// BDE_VERIFY pragma: pop

struct InvokeResult_ImpUtils
{
    // Utility metaprogramming functions inherited by other metaprogramming
    // classes.

    // TYPES
    struct AnyLvalue {
        // Type convertible from any lvalue type.  Used for overload resolution
        // in metafunctions.

        // CREATORS
        template <class t_TP>
        AnyLvalue(volatile t_TP&);
            // (Declared but not defined) Convert from any lvalue argument.
    };

    struct AnyRvalue {
        // Type convertible from any rvalue type.  Used for overload resolution
        // in metafunctions.

        // CREATORS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        template <class t_TP>
        AnyRvalue(
               t_TP&&,
               typename bsl::enable_if<bsl::is_rvalue_reference<t_TP&&>::value,
                                       int>::type = 0);
            // (Declared but not defined) Convert from any rvalue argument.
#else
        template <class t_TP>
        AnyRvalue(t_TP);
            // (Declared but not defined) Convert from any rvalue argument.
            // This constructor will also match lvalue arguments, but is used
            // in a context where 'AnyLValue' is a better conversion path.
#endif
    };

    // CLASS METHODS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class t_SOME_TYPE>
    static typename bsl::add_rvalue_reference<t_SOME_TYPE>::type myDeclval();
        // Return a reference to the specified 't_SOME_TYPE' template parameter
        // type; if 't_SOME_TYPE' is an rvalue, then the returned reference is
        // an rvalue reference.  This function is declared but not defined and
        // is intended to be called in an unevaluated context.  Because there
        // is no definition, the available constructors for 't_SOME_TYPE' are
        // irrelevant.
#else
    template <class t_SOME_TYPE>
    static t_SOME_TYPE myDeclval();
        // Return an object of the specified 't_SOME_TYPE' template parameter
        // type.  This function is declared but not defined and is intended to
        // be called in an unevaluated context.  Because there is no
        // definition, the available constructors for 't_SOME_TYPE' are
        // irrelevant.
#endif

    static bslmf::Tag<false>    checkLvalue(AnyRvalue, ...);
    static bslmf::Tag<true >    checkLvalue(AnyLvalue, int);
        // (Declared but not defined) Return 'bslmf::Tag<false>()' if the
        // first argument is an rvalue and 'bslmf::Tag<true>()' if it is
        // lvalue.  In actual use, the second argument is always a literal
        // 'int', which causes the second overload to be preferred in case of
        // ambiguity.

    template <class t_TP>
    static bslmf::Tag<false> checkConst(t_TP&);
    template <class t_TP>
    static bslmf::Tag<true> checkConst(const t_TP&);
        // (Declared but not defined) Return 'bslmf::Tag<true>()' if the
        // argument is 'const'-qualified and 'bslmf::Tag<false>()' otherwise.

    template <class t_TP>
    static bslmf::Tag<false> checkVolatile(t_TP&);
    template <class t_TP>
    static bslmf::Tag<false> checkVolatile(const t_TP&);
    template <class t_TP>
    static bslmf::Tag<true> checkVolatile(volatile t_TP&);
    template <class t_TP>
    static bslmf::Tag<true> checkVolatile(const volatile t_TP&);
        // (Declared but not defined) Return 'bslmf::Tag<true>()' if the
        // argument is 'volatile'-qualified and 'bslmf::Tag<false>()'
        // otherwise.  Note that if 't_TP' is both const- and
        // volatile-qualified, it will not match 'volatile t_TP&', hence the
        // need for the const overloads.

    template <class t_TP>
    static t_TP& uncv(const t_TP&);
    template <class t_TP>
    static t_TP& uncv(const volatile t_TP&);
        // (Declared but not defined) Return the argument, with cv-qualifiers
        // removed.

    template <class t_TP>
    static t_TP& unpoint(t_TP&);
    template <class t_TP>
    static const t_TP& unpoint(const t_TP&);
    template <class t_TP>
    static typename bsl::enable_if<!bsl::is_void<t_TP>::value, t_TP>::type&
    unpoint(t_TP *&);
    template <class t_TP>
    static typename bsl::enable_if<!bsl::is_void<t_TP>::value, t_TP>::type&
    unpoint(t_TP *const&);
    template <class t_TP>
    static typename bsl::enable_if<!bsl::is_void<t_TP>::value, t_TP>::type&
    unpoint(t_TP *volatile&);
    template <class t_TP>
    static typename bsl::enable_if<!bsl::is_void<t_TP>::value, t_TP>::type&
    unpoint(t_TP *const volatile&);
        // If the argument type 't_TP' is pointer to type 'X', where 'X' is not
        // cv-'void', return a reference to 'X'; otherwise return a reference
        // to 't_TP'.  Note that these functions are declared but not defined
        // and are intended to be called only in an unevaluated context.
};

template <class t_UNQUAL_TYPE,
          bool t_IS_CONST,
          bool t_IS_VOLATILE,
          bool t_IS_LVALUE>
struct InvokeResult_AddCVRef {
    // Starting with type, 't_UNQUAL_TYPE', generate a new type by applying the
    // following steps in order:
    //
    //: 1 If the specified 't_IS_CONST' parameter is true, apply
    //:   'bsl::add_const'; otherwise leave unchanged.
    //: 2 If the specified 't_IS_VOLATILE' parameter is true, apply
    //:   'bsl::add_volatile'; otherwise leave unchanged.
    //: 3 If the specified 't_IS_LVALUE' parameter is true, apply
    //:   'bsl::add_lvalue_reference'; otherwise leave unchanged.
    //
    // Set the 'type' member to the resulting type.

  private:
    // PRIVATE TYPES
    typedef
        typename bsl::conditional<t_IS_CONST,
                                  typename bsl::add_const<t_UNQUAL_TYPE>::type,
                                  t_UNQUAL_TYPE>::type CQualType;

    typedef
        typename bsl::conditional<t_IS_VOLATILE,
                                  typename bsl::add_volatile<CQualType>::type,
                                  CQualType>::type CVQualType;

  public:
    // TYPES
    typedef typename bsl::conditional<
        t_IS_LVALUE,
        typename bsl::add_lvalue_reference<CVQualType>::type,
        CVQualType>::type type;
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_D
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_D BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

#ifndef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <bool __Param__0,
          class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FunctorDeduction;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
template <bool __Param__0, class t_FN>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()()))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()())),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 ))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()())))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()()))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()()))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
template <bool __Param__0, class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08,
                                       class t_ARGTYPES_09>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08,
                                                       t_ARGTYPES_09
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>(),
                                              myDeclval<t_ARGTYPES_09>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>(),
                                               myDeclval<t_ARGTYPES_09>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08,
                                       class t_ARGTYPES_09,
                                       class t_ARGTYPES_10>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08,
                                                       t_ARGTYPES_09,
                                                       t_ARGTYPES_10
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>(),
                                              myDeclval<t_ARGTYPES_09>(),
                                              myDeclval<t_ARGTYPES_10>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>(),
                                               myDeclval<t_ARGTYPES_09>(),
                                               myDeclval<t_ARGTYPES_10>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08,
                                       class t_ARGTYPES_09,
                                       class t_ARGTYPES_10,
                                       class t_ARGTYPES_11>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08,
                                                       t_ARGTYPES_09,
                                                       t_ARGTYPES_10,
                                                       t_ARGTYPES_11
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>(),
                                              myDeclval<t_ARGTYPES_09>(),
                                              myDeclval<t_ARGTYPES_10>(),
                                              myDeclval<t_ARGTYPES_11>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>(),
                                               myDeclval<t_ARGTYPES_09>(),
                                               myDeclval<t_ARGTYPES_10>(),
                                               myDeclval<t_ARGTYPES_11>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08,
                                       class t_ARGTYPES_09,
                                       class t_ARGTYPES_10,
                                       class t_ARGTYPES_11,
                                       class t_ARGTYPES_12>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08,
                                                       t_ARGTYPES_09,
                                                       t_ARGTYPES_10,
                                                       t_ARGTYPES_11,
                                                       t_ARGTYPES_12
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>(),
                                              myDeclval<t_ARGTYPES_09>(),
                                              myDeclval<t_ARGTYPES_10>(),
                                              myDeclval<t_ARGTYPES_11>(),
                                              myDeclval<t_ARGTYPES_12>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>(),
                                                 myDeclval<t_ARGTYPES_12>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>(),
                                                 myDeclval<t_ARGTYPES_12>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>(),
                                               myDeclval<t_ARGTYPES_09>(),
                                               myDeclval<t_ARGTYPES_10>(),
                                               myDeclval<t_ARGTYPES_11>(),
                                               myDeclval<t_ARGTYPES_12>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13
template <bool __Param__0, class t_FN, class t_ARGTYPES_01,
                                       class t_ARGTYPES_02,
                                       class t_ARGTYPES_03,
                                       class t_ARGTYPES_04,
                                       class t_ARGTYPES_05,
                                       class t_ARGTYPES_06,
                                       class t_ARGTYPES_07,
                                       class t_ARGTYPES_08,
                                       class t_ARGTYPES_09,
                                       class t_ARGTYPES_10,
                                       class t_ARGTYPES_11,
                                       class t_ARGTYPES_12,
                                       class t_ARGTYPES_13>
struct InvokeResult_FunctorDeduction<__Param__0, t_FN, t_ARGTYPES_01,
                                                       t_ARGTYPES_02,
                                                       t_ARGTYPES_03,
                                                       t_ARGTYPES_04,
                                                       t_ARGTYPES_05,
                                                       t_ARGTYPES_06,
                                                       t_ARGTYPES_07,
                                                       t_ARGTYPES_08,
                                                       t_ARGTYPES_09,
                                                       t_ARGTYPES_10,
                                                       t_ARGTYPES_11,
                                                       t_ARGTYPES_12,
                                                       t_ARGTYPES_13
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>(),
                                                myDeclval<t_ARGTYPES_13>())))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                              myDeclval<t_ARGTYPES_02>(),
                                              myDeclval<t_ARGTYPES_03>(),
                                              myDeclval<t_ARGTYPES_04>(),
                                              myDeclval<t_ARGTYPES_05>(),
                                              myDeclval<t_ARGTYPES_06>(),
                                              myDeclval<t_ARGTYPES_07>(),
                                              myDeclval<t_ARGTYPES_08>(),
                                              myDeclval<t_ARGTYPES_09>(),
                                              myDeclval<t_ARGTYPES_10>(),
                                              myDeclval<t_ARGTYPES_11>(),
                                              myDeclval<t_ARGTYPES_12>(),
                                              myDeclval<t_ARGTYPES_13>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>(),
                                                 myDeclval<t_ARGTYPES_12>(),
                                                 myDeclval<t_ARGTYPES_13>()))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES_01>(),
                                                 myDeclval<t_ARGTYPES_02>(),
                                                 myDeclval<t_ARGTYPES_03>(),
                                                 myDeclval<t_ARGTYPES_04>(),
                                                 myDeclval<t_ARGTYPES_05>(),
                                                 myDeclval<t_ARGTYPES_06>(),
                                                 myDeclval<t_ARGTYPES_07>(),
                                                 myDeclval<t_ARGTYPES_08>(),
                                                 myDeclval<t_ARGTYPES_09>(),
                                                 myDeclval<t_ARGTYPES_10>(),
                                                 myDeclval<t_ARGTYPES_11>(),
                                                 myDeclval<t_ARGTYPES_12>(),
                                                 myDeclval<t_ARGTYPES_13>()))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                               myDeclval<t_ARGTYPES_02>(),
                                               myDeclval<t_ARGTYPES_03>(),
                                               myDeclval<t_ARGTYPES_04>(),
                                               myDeclval<t_ARGTYPES_05>(),
                                               myDeclval<t_ARGTYPES_06>(),
                                               myDeclval<t_ARGTYPES_07>(),
                                               myDeclval<t_ARGTYPES_08>(),
                                               myDeclval<t_ARGTYPES_09>(),
                                               myDeclval<t_ARGTYPES_10>(),
                                               myDeclval<t_ARGTYPES_11>(),
                                               myDeclval<t_ARGTYPES_12>(),
                                               myDeclval<t_ARGTYPES_13>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>(),
                                                myDeclval<t_ARGTYPES_13>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                myDeclval<t_ARGTYPES_02>(),
                                                myDeclval<t_ARGTYPES_03>(),
                                                myDeclval<t_ARGTYPES_04>(),
                                                myDeclval<t_ARGTYPES_05>(),
                                                myDeclval<t_ARGTYPES_06>(),
                                                myDeclval<t_ARGTYPES_07>(),
                                                myDeclval<t_ARGTYPES_08>(),
                                                myDeclval<t_ARGTYPES_09>(),
                                                myDeclval<t_ARGTYPES_10>(),
                                                myDeclval<t_ARGTYPES_11>(),
                                                myDeclval<t_ARGTYPES_12>(),
                                                myDeclval<t_ARGTYPES_13>())))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
template <class t_FN>
struct InvokeResult_FunctorDeduction<true , t_FN> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12,
                                                  t_ARGTYPES_13> {

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

#ifndef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <bool , class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorDeduction : InvokeResult_ImpUtils {

    typedef typename bsl::decay<t_FN>::type F;

    enum {

        k_INDEX      = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                         uncv(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...)))),
        k_IS_POINTER = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(
                checkLvalue(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...), 0)),
        k_IS_CONST_PTR = k_IS_POINTER &&
                         BSLMF_TAG_TO_INT(checkConst(
                               myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...))),
        k_IS_VOLATILE_PTR = k_IS_POINTER &&
                            BSLMF_TAG_TO_INT(checkVolatile(myDeclval<t_FN>()(
                                                 myDeclval<t_ARGTYPES>()...))),
        k_TARGET_INDEX = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                uncv(unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...)))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                      unpoint(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...)))),
        k_CANT_DEDUCE_TYPE   = (k_TARGET_INDEX ==
                                (int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorDeduction<true , t_FN, t_ARGTYPES...> {

    typedef void type;
};
#endif

// }}} END GENERATED CODE
#endif

template <class t_MEMOF_CLASS,
          class t_ARG_TYPE,
          bool t_IS_DERIVED = bsl::is_convertible<
              typename bsl::decay<t_ARG_TYPE>::type *,
              typename bsl::decay<t_MEMOF_CLASS>::type *>::value>
struct InvokeResult_MemPtrArgQualifiers {
    // This metafunction determines which cv qualifiers and reference
    // qualifiers should be propagated from the first argument of
    // 'invoke_result'.  This primary template is instantiated when
    // 't_ARG_TYPE' is the same or is derived from 't_MEMOF_CLASS'.  The
    // constant 'k_IS_LVALUE' is true iff 't_ARG_TYPE' is an lvalue reference;
    // the constant 'k_IS_CONST' is true iff 't_ARG_TYPE' is const-qualified;
    // and the constant 'k_IS_VOLATILE' is true iff 't_ARG_TYPE' is
    // volatile-qualified.

    // TYPES
    enum {
        k_IS_LVALUE = bsl::is_lvalue_reference<t_ARG_TYPE>::value,
        k_IS_CONST  = bsl::is_const<
            typename bsl::remove_reference<t_ARG_TYPE>::type>::value,
        k_IS_VOLATILE = bsl::is_volatile<
            typename bsl::remove_reference<t_ARG_TYPE>::type>::value
    };
};

template <class t_MEMOF_CLASS, class t_ARG_TYPE>
struct InvokeResult_MemPtrArgQualifiers<t_MEMOF_CLASS, t_ARG_TYPE, false>
: InvokeResult_ImpUtils {
    // This metafunction determines which cv qualifiers and reference
    // qualifiers should be propagated from the first argument of
    // 'invoke_result'.
    //
    // This specialization is instantiated when 't_ARG_TYPE' is not derived
    // from 't_MEMOF_CLASS' and is assumed to be a pointer or smart pointer
    // type.  If type 'A' is the result of dereferencing an object of type
    // 't_ARG_TYPE', then the constant 'k_IS_LVALUE' is true iff 'A' is an
    // lvalue reference; the constant 'k_IS_CONST' is true iff 'A' is a
    // const-qualified reference; and the constant 'k_IS_VOLATILE' is true iff
    // 'A' is a volatile-qualified reference.

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
  private:
    // CLASS METHODS
    template <class t_TP>
    static t_TP& tolvalue(t_TP&&);
        // (Declared but not defined.)  Return an lvalue reference
        // corresponding of the specified 't_TP' type, which is deduced from
        // the specified unnamed argument.  If the argument is an lvalue, the
        // return type is identical to the argument type.  If the argument is
        // an rvalue, the return type is an lvalue to the argument type with
        // the same cv qualifiers.  This function is useful for avoiding too
        // many redundant overloads in metafunctions that determine cv
        // qualifications, etc.

  public:
    // TYPES
    enum {k_IS_LVALUE = BSLMF_TAG_TO_INT(checkLvalue(*myDeclval<t_ARG_TYPE>(),
                                                     0)),
          k_IS_CONST =
              BSLMF_TAG_TO_INT(checkConst(tolvalue(*myDeclval<t_ARG_TYPE>()))),
          k_IS_VOLATILE = BSLMF_TAG_TO_INT(
              checkVolatile(tolvalue(*myDeclval<t_ARG_TYPE>())))};
#else
  public:
    // TYPES
    enum {
        k_IS_LVALUE = BSLMF_TAG_TO_INT(checkLvalue(*myDeclval<t_ARG_TYPE>(),
                                                   0)),
        // In C++03, cv qualifiers are discarded from rvalues.
        k_IS_CONST = k_IS_LVALUE &&
                     BSLMF_TAG_TO_INT(checkConst(*myDeclval<t_ARG_TYPE>())),
        k_IS_VOLATILE = k_IS_LVALUE && BSLMF_TAG_TO_INT(checkVolatile(
                                                     *myDeclval<t_ARG_TYPE>()))
    };
#endif // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_E
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_E BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class t_VOID_TYPE,
          class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FunctorImp;


template <class t_VOID_TYPE,
          class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FuncPtrImp;


template <class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemFuncPtrImp;


template <class t_FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemObjPtrImp;



#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN
                                       > : InvokeResult_FunctorImp<void, t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                  t_ARGTYPES_01
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08,
                                                                 t_ARGTYPES_09
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08,
                                                                 t_ARGTYPES_09,
                                                                 t_ARGTYPES_10
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08,
                                                                 t_ARGTYPES_09,
                                                                 t_ARGTYPES_10,
                                                                 t_ARGTYPES_11
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08,
                                                                 t_ARGTYPES_09,
                                                                 t_ARGTYPES_10,
                                                                 t_ARGTYPES_11,
                                                                 t_ARGTYPES_12
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11,
                                                               t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <bool t_IS_FUNCPTR, bool t_IS_MEMFUNCPTR, bool t_IS_MEMOBJPTR,
          class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_Imp<t_IS_FUNCPTR, t_IS_MEMFUNCPTR, t_IS_MEMOBJPTR, t_FN,
                                                                 t_ARGTYPES_01,
                                                                 t_ARGTYPES_02,
                                                                 t_ARGTYPES_03,
                                                                 t_ARGTYPES_04,
                                                                 t_ARGTYPES_05,
                                                                 t_ARGTYPES_06,
                                                                 t_ARGTYPES_07,
                                                                 t_ARGTYPES_08,
                                                                 t_ARGTYPES_09,
                                                                 t_ARGTYPES_10,
                                                                 t_ARGTYPES_11,
                                                                 t_ARGTYPES_12,
                                                                 t_ARGTYPES_13
                                       > : InvokeResult_FunctorImp<void, t_FN,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11,
                                                               t_ARGTYPES_12,
                                                               t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN>
: InvokeResult_FuncPtrImp<void, t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08,
                                      t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08,
                                      t_ARGTYPES_09,
                                      t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08,
                                      t_ARGTYPES_09,
                                      t_ARGTYPES_10,
                                      t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08,
                                      t_ARGTYPES_09,
                                      t_ARGTYPES_10,
                                      t_ARGTYPES_11,
                                      t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12,
                        t_ARGTYPES_13>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES_01,
                                      t_ARGTYPES_02,
                                      t_ARGTYPES_03,
                                      t_ARGTYPES_04,
                                      t_ARGTYPES_05,
                                      t_ARGTYPES_06,
                                      t_ARGTYPES_07,
                                      t_ARGTYPES_08,
                                      t_ARGTYPES_09,
                                      t_ARGTYPES_10,
                                      t_ARGTYPES_11,
                                      t_ARGTYPES_12,
                                      t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN>
: InvokeResult_MemFuncPtrImp<t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08,
                                   t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08,
                                   t_ARGTYPES_09,
                                   t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08,
                                   t_ARGTYPES_09,
                                   t_ARGTYPES_10,
                                   t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08,
                                   t_ARGTYPES_09,
                                   t_ARGTYPES_10,
                                   t_ARGTYPES_11,
                                   t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12,
                        t_ARGTYPES_13>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                   t_ARGTYPES_02,
                                   t_ARGTYPES_03,
                                   t_ARGTYPES_04,
                                   t_ARGTYPES_05,
                                   t_ARGTYPES_06,
                                   t_ARGTYPES_07,
                                   t_ARGTYPES_08,
                                   t_ARGTYPES_09,
                                   t_ARGTYPES_10,
                                   t_ARGTYPES_11,
                                   t_ARGTYPES_12,
                                   t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN>
: InvokeResult_MemObjPtrImp<t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08,
                                  t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08,
                                  t_ARGTYPES_09,
                                  t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08,
                                  t_ARGTYPES_09,
                                  t_ARGTYPES_10,
                                  t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08,
                                  t_ARGTYPES_09,
                                  t_ARGTYPES_10,
                                  t_ARGTYPES_11,
                                  t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES_01,
                        t_ARGTYPES_02,
                        t_ARGTYPES_03,
                        t_ARGTYPES_04,
                        t_ARGTYPES_05,
                        t_ARGTYPES_06,
                        t_ARGTYPES_07,
                        t_ARGTYPES_08,
                        t_ARGTYPES_09,
                        t_ARGTYPES_10,
                        t_ARGTYPES_11,
                        t_ARGTYPES_12,
                        t_ARGTYPES_13>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                  t_ARGTYPES_02,
                                  t_ARGTYPES_03,
                                  t_ARGTYPES_04,
                                  t_ARGTYPES_05,
                                  t_ARGTYPES_06,
                                  t_ARGTYPES_07,
                                  t_ARGTYPES_08,
                                  t_ARGTYPES_09,
                                  t_ARGTYPES_10,
                                  t_ARGTYPES_11,
                                  t_ARGTYPES_12,
                                  t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13



#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_VOID_TYPE, class t_FN>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12,
                                         class t_ARGTYPES_13>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12,
                                                  t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    ))>::type,
    t_FN> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>()))>::type,
    t_FN,
    t_ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>(),
                                       myDeclval<t_ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_13>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12,
    t_ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>(),
                                       myDeclval<t_ARGTYPES_12>(),
                                       myDeclval<t_ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_VOID_TYPE, class t_FN>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN> : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>(),
                                                   myDeclval<t_ARGTYPES_09>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08,
                                                   t_ARGTYPES_09>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>(),
                                                   myDeclval<t_ARGTYPES_09>(),
                                                   myDeclval<t_ARGTYPES_10>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08,
                                                   t_ARGTYPES_09,
                                                   t_ARGTYPES_10>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>(),
                                                   myDeclval<t_ARGTYPES_09>(),
                                                   myDeclval<t_ARGTYPES_10>(),
                                                   myDeclval<t_ARGTYPES_11>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08,
                                                   t_ARGTYPES_09,
                                                   t_ARGTYPES_10,
                                                   t_ARGTYPES_11>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>(),
                                                   myDeclval<t_ARGTYPES_09>(),
                                                   myDeclval<t_ARGTYPES_10>(),
                                                   myDeclval<t_ARGTYPES_11>(),
                                                   myDeclval<t_ARGTYPES_12>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08,
                                                   t_ARGTYPES_09,
                                                   t_ARGTYPES_10,
                                                   t_ARGTYPES_11,
                                                   t_ARGTYPES_12>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12,
                                         class t_ARGTYPES_13>
struct InvokeResult_FunctorImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12,
                                                  t_ARGTYPES_13
                                                  > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                                   myDeclval<t_ARGTYPES_02>(),
                                                   myDeclval<t_ARGTYPES_03>(),
                                                   myDeclval<t_ARGTYPES_04>(),
                                                   myDeclval<t_ARGTYPES_05>(),
                                                   myDeclval<t_ARGTYPES_06>(),
                                                   myDeclval<t_ARGTYPES_07>(),
                                                   myDeclval<t_ARGTYPES_08>(),
                                                   myDeclval<t_ARGTYPES_09>(),
                                                   myDeclval<t_ARGTYPES_10>(),
                                                   myDeclval<t_ARGTYPES_11>(),
                                                   myDeclval<t_ARGTYPES_12>(),
                                                   myDeclval<t_ARGTYPES_13>()),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES_01,
                                                   t_ARGTYPES_02,
                                                   t_ARGTYPES_03,
                                                   t_ARGTYPES_04,
                                                   t_ARGTYPES_05,
                                                   t_ARGTYPES_06,
                                                   t_ARGTYPES_07,
                                                   t_ARGTYPES_08,
                                                   t_ARGTYPES_09,
                                                   t_ARGTYPES_10,
                                                   t_ARGTYPES_11,
                                                   t_ARGTYPES_12,
                                                   t_ARGTYPES_13>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_VOID_TYPE, class t_FN>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12,
                                         class t_ARGTYPES_13>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12,
                                                  t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    ))>::type,
    t_FN> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>()))>::type,
    t_FN,
    t_ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>(),
                                       myDeclval<t_ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_13>()))>::type,
    t_FN,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12,
    t_ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES_01>(),
                                       myDeclval<t_ARGTYPES_02>(),
                                       myDeclval<t_ARGTYPES_03>(),
                                       myDeclval<t_ARGTYPES_04>(),
                                       myDeclval<t_ARGTYPES_05>(),
                                       myDeclval<t_ARGTYPES_06>(),
                                       myDeclval<t_ARGTYPES_07>(),
                                       myDeclval<t_ARGTYPES_08>(),
                                       myDeclval<t_ARGTYPES_09>(),
                                       myDeclval<t_ARGTYPES_10>(),
                                       myDeclval<t_ARGTYPES_11>(),
                                       myDeclval<t_ARGTYPES_12>(),
                                       myDeclval<t_ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_VOID_TYPE, class t_FN>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_VOID_TYPE, class t_FN, class t_ARGTYPES_01,
                                         class t_ARGTYPES_02,
                                         class t_ARGTYPES_03,
                                         class t_ARGTYPES_04,
                                         class t_ARGTYPES_05,
                                         class t_ARGTYPES_06,
                                         class t_ARGTYPES_07,
                                         class t_ARGTYPES_08,
                                         class t_ARGTYPES_09,
                                         class t_ARGTYPES_10,
                                         class t_ARGTYPES_11,
                                         class t_ARGTYPES_12,
                                         class t_ARGTYPES_13>
struct InvokeResult_FuncPtrImp<t_VOID_TYPE, t_FN, t_ARGTYPES_01,
                                                  t_ARGTYPES_02,
                                                  t_ARGTYPES_03,
                                                  t_ARGTYPES_04,
                                                  t_ARGTYPES_05,
                                                  t_ARGTYPES_06,
                                                  t_ARGTYPES_07,
                                                  t_ARGTYPES_08,
                                                  t_ARGTYPES_09,
                                                  t_ARGTYPES_10,
                                                  t_ARGTYPES_11,
                                                  t_ARGTYPES_12,
                                                  t_ARGTYPES_13> {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARG1TYPE
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class t_ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class t_ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class t_ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class t_ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class t_ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class t_ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class t_ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class t_ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class t_ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class t_ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class t_ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class t_ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class t_ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemFuncPtrImpDispatch;


template <class t_FN>
struct InvokeResult_MemFuncPtrImp<t_FN> {
};

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN, class t_ARG1TYPE>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08,
                                                    t_ARGTYPES_09>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08,
      t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08,
                                                    t_ARGTYPES_09,
                                                    t_ARGTYPES_10>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08,
      t_ARGTYPES_09,
      t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08,
                                                    t_ARGTYPES_09,
                                                    t_ARGTYPES_10,
                                                    t_ARGTYPES_11>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08,
      t_ARGTYPES_09,
      t_ARGTYPES_10,
      t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08,
                                                    t_ARGTYPES_09,
                                                    t_ARGTYPES_10,
                                                    t_ARGTYPES_11,
                                                    t_ARGTYPES_12>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08,
      t_ARGTYPES_09,
      t_ARGTYPES_10,
      t_ARGTYPES_11,
      t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12,
                                        class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES_01,
                                                    t_ARGTYPES_02,
                                                    t_ARGTYPES_03,
                                                    t_ARGTYPES_04,
                                                    t_ARGTYPES_05,
                                                    t_ARGTYPES_06,
                                                    t_ARGTYPES_07,
                                                    t_ARGTYPES_08,
                                                    t_ARGTYPES_09,
                                                    t_ARGTYPES_10,
                                                    t_ARGTYPES_11,
                                                    t_ARGTYPES_12,
                                                    t_ARGTYPES_13>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES_01,
      t_ARGTYPES_02,
      t_ARGTYPES_03,
      t_ARGTYPES_04,
      t_ARGTYPES_05,
      t_ARGTYPES_06,
      t_ARGTYPES_07,
      t_ARGTYPES_08,
      t_ARGTYPES_09,
      t_ARGTYPES_10,
      t_ARGTYPES_11,
      t_ARGTYPES_12,
      t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_MemFuncPtrImp<t_FN> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08,
                                        t_ARGTYPES_09> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08,
                                        t_ARGTYPES_09,
                                        t_ARGTYPES_10> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08,
                                        t_ARGTYPES_09,
                                        t_ARGTYPES_10,
                                        t_ARGTYPES_11> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08,
                                        t_ARGTYPES_09,
                                        t_ARGTYPES_10,
                                        t_ARGTYPES_11,
                                        t_ARGTYPES_12> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES_01,
                                        t_ARGTYPES_02,
                                        t_ARGTYPES_03,
                                        t_ARGTYPES_04,
                                        t_ARGTYPES_05,
                                        t_ARGTYPES_06,
                                        t_ARGTYPES_07,
                                        t_ARGTYPES_08,
                                        t_ARGTYPES_09,
                                        t_ARGTYPES_10,
                                        t_ARGTYPES_11,
                                        t_ARGTYPES_12,
                                        t_ARGTYPES_13> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08,
          class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08,
          class t_ARGTYPES_09,
          class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08,
          class t_ARGTYPES_09,
          class t_ARGTYPES_10,
          class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08,
          class t_ARGTYPES_09,
          class t_ARGTYPES_10,
          class t_ARGTYPES_11,
          class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11,
                                                               t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_VOID_TYPE, bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER, class t_FN, class t_ARG1TYPE,
          class t_ARGTYPES_01,
          class t_ARGTYPES_02,
          class t_ARGTYPES_03,
          class t_ARGTYPES_04,
          class t_ARGTYPES_05,
          class t_ARGTYPES_06,
          class t_ARGTYPES_07,
          class t_ARGTYPES_08,
          class t_ARGTYPES_09,
          class t_ARGTYPES_10,
          class t_ARGTYPES_11,
          class t_ARGTYPES_12,
          class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<t_VOID_TYPE, t_ARG1_DERIVES_FROM_CLASS, t_ARG1_IS_REFERENCE_WRAPPER, t_FN, t_ARG1TYPE,
                                                               t_ARGTYPES_01,
                                                               t_ARGTYPES_02,
                                                               t_ARGTYPES_03,
                                                               t_ARGTYPES_04,
                                                               t_ARGTYPES_05,
                                                               t_ARGTYPES_06,
                                                               t_ARGTYPES_07,
                                                               t_ARGTYPES_08,
                                                               t_ARGTYPES_09,
                                                               t_ARGTYPES_10,
                                                               t_ARGTYPES_11,
                                                               t_ARGTYPES_12,
                                                               t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN, class t_ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    ))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12,
                                        class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_13>()))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12,
    t_ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>(),
                                         myDeclval<t_ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN, class t_ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    ))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12,
                                        class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_13>()))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12,
    t_ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>(),
                                         myDeclval<t_ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN, class t_ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    ))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARG1TYPE, class t_ARGTYPES_01,
                                        class t_ARGTYPES_02,
                                        class t_ARGTYPES_03,
                                        class t_ARGTYPES_04,
                                        class t_ARGTYPES_05,
                                        class t_ARGTYPES_06,
                                        class t_ARGTYPES_07,
                                        class t_ARGTYPES_08,
                                        class t_ARGTYPES_09,
                                        class t_ARGTYPES_10,
                                        class t_ARGTYPES_11,
                                        class t_ARGTYPES_12,
                                        class t_ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_01>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_02>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_03>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_04>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_05>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_06>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_07>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_08>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_09>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_10>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_11>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_12>(),
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES_13>()))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES_01,
    t_ARGTYPES_02,
    t_ARGTYPES_03,
    t_ARGTYPES_04,
    t_ARGTYPES_05,
    t_ARGTYPES_06,
    t_ARGTYPES_07,
    t_ARGTYPES_08,
    t_ARGTYPES_09,
    t_ARGTYPES_10,
    t_ARGTYPES_11,
    t_ARGTYPES_12,
    t_ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES_01>(),
                                         myDeclval<t_ARGTYPES_02>(),
                                         myDeclval<t_ARGTYPES_03>(),
                                         myDeclval<t_ARGTYPES_04>(),
                                         myDeclval<t_ARGTYPES_05>(),
                                         myDeclval<t_ARGTYPES_06>(),
                                         myDeclval<t_ARGTYPES_07>(),
                                         myDeclval<t_ARGTYPES_08>(),
                                         myDeclval<t_ARGTYPES_09>(),
                                         myDeclval<t_ARGTYPES_10>(),
                                         myDeclval<t_ARGTYPES_11>(),
                                         myDeclval<t_ARGTYPES_12>(),
                                         myDeclval<t_ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool  t_ARG_DERIVES_FROM_CLASS,
          bool  t_ARG_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_MemObjPtrImp<t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12,
                                       t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPE>
: InvokeResult_MemObjPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARGTYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARGTYPE>::type>::type>::value,
      t_FN,
      t_ARGTYPE> {
};

#else

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class t_FN>
struct InvokeResult_MemObjPtrImp<t_FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class t_FN, class t_ARGTYPES_01>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class t_FN, class t_ARGTYPES_01,
                      class t_ARGTYPES_02,
                      class t_ARGTYPES_03,
                      class t_ARGTYPES_04,
                      class t_ARGTYPES_05,
                      class t_ARGTYPES_06,
                      class t_ARGTYPES_07,
                      class t_ARGTYPES_08,
                      class t_ARGTYPES_09,
                      class t_ARGTYPES_10,
                      class t_ARGTYPES_11,
                      class t_ARGTYPES_12,
                      class t_ARGTYPES_13>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES_01,
                                       t_ARGTYPES_02,
                                       t_ARGTYPES_03,
                                       t_ARGTYPES_04,
                                       t_ARGTYPES_05,
                                       t_ARGTYPES_06,
                                       t_ARGTYPES_07,
                                       t_ARGTYPES_08,
                                       t_ARGTYPES_09,
                                       t_ARGTYPES_10,
                                       t_ARGTYPES_11,
                                       t_ARGTYPES_12,
                                       t_ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


template <class t_CLASS, class t_RET, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImp<t_RET t_CLASS::*, t_ARGTYPE> {

  private:
    typedef InvokeResult_MemPtrArgQualifiers<t_CLASS, t_ARGTYPE> ArgQualifiers;

    typedef typename InvokeResult_AddCVRef<t_RET,
                                           ArgQualifiers::k_IS_CONST,
                                           ArgQualifiers::k_IS_VOLATILE,
                                           ArgQualifiers::k_IS_LVALUE>::type
        cvtype;

  public:
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    typedef typename bsl::conditional<
        ArgQualifiers::k_IS_LVALUE,
        cvtype,
        typename bsl::add_rvalue_reference<cvtype>::type>::type type;
#else
    typedef cvtype type;
#endif
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool  t_ARG_DERIVES_FROM_CLASS,
          bool  t_ARG_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch {
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((*InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>()).*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
false,
false,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype((*myDeclval<t_ARGTYPE>()).*myDeclval<t_FN>()) type;
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>().*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
true,
false,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_ARGTYPE>().*myDeclval<t_FN>()) type;
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>().get().*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
false,
true,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_ARGTYPE>().get().*myDeclval<t_FN>()) type;
};

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorImp;

template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FuncPtrImp;

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImp;

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_MemObjPtrImp;


template <bool t_IS_FUNCPTR,
          bool t_IS_MEMFUNCPTR,
          bool t_IS_MEMOBJPTR,
          class t_FN,
          class... t_ARGTYPES>
struct InvokeResult_Imp : InvokeResult_FunctorImp<void, t_FN, t_ARGTYPES...> {
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_Imp<true ,
                        false,
                        false,
                        t_FN,
                        t_ARGTYPES...>
: InvokeResult_FuncPtrImp<void, t_FN, t_ARGTYPES...> {
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_Imp<false,
                        true ,
                        false,
                        t_FN,
                        t_ARGTYPES...>
: InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES...> {
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_Imp<false,
                        false,
                        true ,
                        t_FN,
                        t_ARGTYPES...>
: InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPES...> {
};


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorImp {
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES>()...))>::type,
    t_FN,
    t_ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...)) type;
};
#else
template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FunctorImp : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID = BSLMF_TAG_TO_INT((
                                 myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...),
                                 InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   t_FN,
                                                   t_ARGTYPES...>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FuncPtrImp {
};

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<t_FN>()(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES>()...))>::type,
    t_FN,
    t_ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_FN>()(myDeclval<t_ARGTYPES>()...)) type;
};
#else
template <class t_VOID_TYPE, class t_FN, class... t_ARGTYPES>
struct InvokeResult_FuncPtrImp {

    typedef typename bslmf::FunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool t_ARG1_DERIVES_FROM_CLASS,
          bool t_ARG1_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARG1TYPE,
          class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch;

template <class t_FN>
struct InvokeResult_MemFuncPtrImp<t_FN> {
};

template <class t_FN, class t_ARG1TYPE, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARG1TYPE, t_ARGTYPES...>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberFunctionPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARG1TYPE>::type>::type>::value,
      t_FN,
      t_ARG1TYPE,
      t_ARGTYPES...> {
};
#else
template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImp<t_FN, t_ARGTYPES...> {

    typedef typename MemberFunctionPointerTraits<t_FN>::ResultType QType;

    typedef typename bsl::conditional<
        bsl::is_reference<QType>::value || bsl::is_class<QType>::value,
        QType,
        typename bsl::remove_cv<QType>::type>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class    t_VOID_TYPE,
          bool     t_ARG1_DERIVES_FROM_CLASS,
          bool     t_ARG1_IS_REFERENCE_WRAPPER,
          class    t_FN,
          class    t_ARG1TYPE,
          class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch {
};

template <class t_FN, class t_ARG1TYPE, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(((*InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>()).*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES>()...))>::type,
false,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<t_ARG1TYPE>()).*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES>()...)) type;
};

template <class t_FN, class t_ARG1TYPE, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES>()...))>::type,
true,
false,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES>()...)) type;
};

template <class t_FN, class t_ARG1TYPE, class... t_ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((InvokeResult_ImpUtils::myDeclval<t_ARG1TYPE>().get().*
                  InvokeResult_ImpUtils::myDeclval<t_FN>())(
                    InvokeResult_ImpUtils::myDeclval<t_ARGTYPES>()...))>::type,
false,
true,
    t_FN,
    t_ARG1TYPE,
    t_ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<t_ARG1TYPE>().get().*
                      myDeclval<t_FN>())(myDeclval<t_ARGTYPES>()...)) type;
};

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool  t_ARG_DERIVES_FROM_CLASS,
          bool  t_ARG_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch;

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_MemObjPtrImp {
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImp<t_FN, t_ARGTYPE>
: InvokeResult_MemObjPtrImpDispatch<
      void,
      IsAccessibleBaseOf<
          typename MemberPointerTraits<t_FN>::ClassType,
          typename bsl::remove_reference<t_ARGTYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<t_ARGTYPE>::type>::type>::value,
      t_FN,
      t_ARGTYPE> {
};

#else

template <class t_FN, class... t_ARGTYPES>
struct InvokeResult_MemObjPtrImp {
};

template <class t_CLASS, class t_RET, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImp<t_RET t_CLASS::*, t_ARGTYPE> {

  private:
    typedef InvokeResult_MemPtrArgQualifiers<t_CLASS, t_ARGTYPE> ArgQualifiers;

    typedef typename InvokeResult_AddCVRef<t_RET,
                                           ArgQualifiers::k_IS_CONST,
                                           ArgQualifiers::k_IS_VOLATILE,
                                           ArgQualifiers::k_IS_LVALUE>::type
        cvtype;

  public:
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    typedef typename bsl::conditional<
        ArgQualifiers::k_IS_LVALUE,
        cvtype,
        typename bsl::add_rvalue_reference<cvtype>::type>::type type;
#else
    typedef cvtype type;
#endif
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class t_VOID_TYPE,
          bool  t_ARG_DERIVES_FROM_CLASS,
          bool  t_ARG_IS_REFERENCE_WRAPPER,
          class t_FN,
          class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch {
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype((*InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>()).*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
false,
false,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype((*myDeclval<t_ARGTYPE>()).*myDeclval<t_FN>()) type;
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>().*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
true,
false,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_ARGTYPE>().*myDeclval<t_FN>()) type;
};

template <class t_FN, class t_ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<
        decltype(InvokeResult_ImpUtils::myDeclval<t_ARGTYPE>().get().*
                 InvokeResult_ImpUtils::myDeclval<t_FN>())>::type,
false,
true,
    t_FN,
    t_ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<t_ARGTYPE>().get().*myDeclval<t_FN>()) type;
};

#endif

// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMF_INVOKERESULT_H)
# error Not valid except when included from bslmf_invokeresult.h
#endif // ! defined(COMPILING_BSLMF_INVOKERESULT_H)

#endif // ! defined(INCLUDED_BSLMF_INVOKERESULT_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
